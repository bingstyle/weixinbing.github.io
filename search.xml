<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[OC预处理命令]]></title>
      <url>%2F2016%2F12%2F19%2FOC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。指令用途：12345678910#空指令，无任何效果#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if 如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息 文件包含#include预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。 宏宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。 #运算符出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：12345#definePASTE(n)&quot;adhfkj&quot;#nmain()&#123;printf(&quot;%s &quot;,PASTE(15));&#125; 宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。 ##运算符用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：12345678910#defineNUM(a,b,c)a##b##c#defineSTR(a,b,c)a##b##cmain()&#123;printf(&quot;%d &quot;,NUM(1,2,3));printf(&quot;%s &quot;,STR(&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;));&#125;最后程序的输出为:123aabbcc1 条件编译指令条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。 #if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。 #endif指令用于终止#if预处理指令。 #ifdef和#ifndef用于#define命令定义过则进行编译 #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。 #elif指令综合了#else和#if指令的作用。 其他一些标准指令 #error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。 补充：预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。 情况112345#ifdef _XXXX...程序段1...#else...程序段2...#endif 这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。 情况212345#ifndef _XXXX ...程序段1... #else ...程序段2... #endif 这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。 情况312345#if 常量 ...程序段1...#else...程序段2...#endif 这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 结合 Github 搭建的博客]]></title>
      <url>%2F2016%2F12%2F18%2FHexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[配置环境 安装Node.js 官网https://nodejs.org/en/ 安装Git（Xcode自带有Git） 注册GitHub账号（用于博客的远程仓库） 安装Hexo打开终端，执行命令： npm install hexo-cli -g 如果报错，加上sudo。hexo常用命令：12345hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章hexo clean #清除生成的文件 初始化博客文件夹hexo init [文件夹名字] cd [文件夹名字] npm install 成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： http://localhost:4000 ： hexo s 如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试： npm install hexo-server --save 编辑hexo的配置文件不要被文件内容吓到了，只需要修改以下地方：1234567# Sitetitle: xxxsubtitle: xxxdescription: xxxauthor: xxxlanguage: zh-Hanstimezone: Asia/Shanghai 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github仓库的克隆地址 branch: master 部署通常情况下是先生成网站，然后部署。可以将两个步骤放到一起： hexo d -g 现在你就可以打开网站看到效果了。如果提示： ERROR Deployer not found:git 需要要安装hexo-deployer-git： npm install hexo-deployer-git --save 完成后执行部署命令hexo d -g。 发布通过以下命令新建文章： hexo new “文章名字&quot; 然后用编辑器打开 source_posts 里的md文件编辑。更新文章： hexo d -g 这样就可以把你的新文章传上去啦。 主题NexT 官方WiKi]]></content>
    </entry>

    
  
  
</search>
