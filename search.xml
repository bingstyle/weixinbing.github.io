<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[View层代码结构规范]]></title>
      <url>%2F2017%2F07%2F10%2F%E5%85%B3%E4%BA%8EView%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[针对View层的架构设计，还是要做好三点： 代码规范 架构模式 工具集 View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。各自实现或者使用CocoaPods里现成的都不是很难。 关于View的代码规范目的: 提高业务方View层的可读性可维护性 防止业务代码对架构产生腐蚀 保持架构发展的方向不轻易被不合理的意见所左右 确保传承 1234567891011121314151617181920212223#pragma mark - Init/* init, dealloc */#pragma mark - Life cycle- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;#pragma mark - Delegate#pragma mark - Event response/* 所有button、gestureRecognizer的响应事件都放在这个区域里面 */#pragma mark - Private methods/* 关于private methods，正常情况下ViewController里面不应该写, 要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。*/#pragma mark - Getters and setters 在viewDidload里面只做addSubview的事情在viewDidAppear里面做Notification的监听之类的事情在updateViewConstraints里面做add constraints的事情属性的初始化，则交给getter去做每一个delegate都把对应的protocol名字带上所有button、gestureRecognizer的响应事件都放在Event response这个区域里面 关于View的布局苹果文档中指出，updateViewConstraints是用来做add constraints的地方。建议使用Masonry，代码的可读性就能好很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[View层代码结构规范]]></title>
      <url>%2F2017%2F07%2F10%2FView%E5%B1%82%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[针对View层的架构设计，还是要做好三点： 代码规范 架构模式 工具集 View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。各自实现或者使用CocoaPods里现成的都不是很难。 关于View的代码规范目的: 提高业务方View层的可读性可维护性 防止业务代码对架构产生腐蚀 保持架构发展的方向不轻易被不合理的意见所左右 确保传承 1234567891011121314151617181920212223#pragma mark - Init/* init, dealloc */#pragma mark - Life cycle- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;#pragma mark - Delegate#pragma mark - Event response/* 所有button、gestureRecognizer的响应事件都放在这个区域里面 */#pragma mark - Private methods/* 关于private methods，正常情况下ViewController里面不应该写, 要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。*/#pragma mark - Getters and setters 在viewDidload里面只做addSubview的事情在viewDidAppear里面做Notification的监听之类的事情在updateViewConstraints里面做add constraints的事情属性的初始化，则交给getter去做每一个delegate都把对应的protocol名字带上所有button、gestureRecognizer的响应事件都放在Event response这个区域里面 关于View的布局苹果文档中指出，updateViewConstraints是用来做add constraints的地方。建议使用Masonry，代码的可读性就能好很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac工具箱]]></title>
      <url>%2F2017%2F05%2F13%2FMac%E5%B7%A5%E5%85%B7%E7%AE%B1%2F</url>
      <content type="text"><![CDATA[AlfredAlfred是我见过的最能将Mac的效率使用到极致的工具了。小到翻译一个英文单词，搜索一个文件，大到用一个命令完成本地开发环境的部署启动，都可以通过Alfred来完成。你可以将大部分的重复劳动让Alfred来帮助你完成。Sketch 3一款UI设计工具。Sketch只有几十M，相较于Photoshop,它小巧得多，更重要的是它是专为UI设计而生的，我不必关注那些与我做UI设计毫无关系的图片处理功能，从而降低了工作环境中的噪音。另外，通过强大的插件功能，我能根据需要进行安装使用，这大大提高了我的工作效率。 PaintCode你可以使用PaintCode方便地进行图形设计，你也可以将SVG或PSD文件导入到PaintCode中，然后它就能帮助你将你的设计转换成Objective-C,Swift或C#代码。 Sip for Mac and iPhoneSip是一个非常出色的iOS app，它能帮助你从照片中创建色板。并且你可以在你的Mac或手机上随时随地使用它捕捉那些美丽的色彩。 Sublime Text 3这是我开发前端代码时 使用的IDE。我非常喜欢它的那些使代码异常清晰的主题，以及功能丰富的插件。有了它开发HTML、CSS、JavaScript变成了一件非常愉悦的事情。 DashDash对开发人员非常有帮助，我能够在离线的状态下查看如Angular，Swift，CSS等的技术文档。这使得我在网络条件不好的情况下也能工作，并且极大提升我的工作效率。 CCheatSheetCheatSheet是我非常喜欢的一个小工具，任何流行的软件都会有一堆的快捷键设置，通过这个工具，你只需要长按?键，这个软件的所有快捷键就会显示在你的面前，你完全不用逐一去背，只要反复查看几次，你自然就能熟练运用那些快捷键了。 Fantastical我使用Fantastical来快速地记录我的todo事项，并设定提醒。我只记录那些比较重要的事项，而不会每天把所有很细小的行动项都记录下来，因为那样反而会让我有一种压迫感而分心。我更喜欢在自然舒缓的环境中工作。 LiceCap这使一个很小的免费软件，你可以在屏幕上设定一个区域，然后就可以用LiceCap来快速地录制GIF动画了。直接、高效是我对它的评价。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令大全]]></title>
      <url>%2F2017%2F01%2F19%2F%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93%2F</url>
      <content type="text"><![CDATA[Git Command 创建仓库 git init 创建git仓库 添加提交 git add 添加(从工作区到暂存区,可多次使用添加多个文件) git commit -m “description” 提交(从暂存区到本地仓库) 查看信息 git status 查看仓库当前状态 git diff 查看添加前修改的内容 git diff HEAD — 查看工作区和版本库最新版本的区别 git log 查看提交日志 git log —pretty=oneline 查看提交日志(单行显示每一条日志) 版本回退 git reset —hard HEAD^ 回滚到上个版本 git reset —hard HEAD^^ 回滚到上上个版本 git reset —hard HEAD~n 回滚到上n个版本 git reset —hard 回滚到指定提交id的版本 撤销修改 rm 删除工作区文件 git checkout — 撤销(丢弃)工作区的修改(让工作区和HEAD保持一致) git reset HEAD 撤销暂存区的文件(个人理解为撤销git add命令) git rm 从版本库中删除文件(会同时删除工作区文件,个人理解为rm 命令 + git add 命令 ) 远程仓库 git remote add origin 关联远程仓库 git push -u origin master 第一次推送master分支的所有内容 git push origin master 推送master分支的所有内容(origin为远程库) git pull —rebase origin master 拉取master分支的内容 git pull 拉取关联的远程分支内容 git branch —set-upstream branch-name origin/branch-name 设置本地分支和远程分支的链接关系**分割线** git clone 克隆远程仓库 分支管理 git branch dev 创建一个dev分支 git checkout dev 切换到dev分支 git checkout -b dev 创建一个dev分支并切换到dev分支 git checkout -b dev origin/dev 创建远程origin的dev分支到本地 git branch 查看分支(列出所有分支,当前分支前有*标记) git merge dev 合并指定分支到当前分支 git merge —no-ff -m “desc” dev 合并dev分支到当前分支并禁用”fast forward” git branch -d dev 删除dev分支 git branch -D dev 强行删除一个没有被合并过的dev分支**分割线** git log —graph 查看分支的合并情况 git log —graph —pretty=oneline 查看分支的合并情况(单行) git log —graph —pretty=oneline —abbrev-commit 查看分支的合并情况(单行短id) 贮藏管理 git stash 贮藏当前工作区的修改(可多次stash) git stash list 查看贮藏列表 git stash apply 恢复stash内容(不删除stash内容) git stash drop 删除stash内容 git stash pop 恢复并删除stash内容 标签管理 git tag 给当前分支上最新的的commitId打上标签 git tag 查看所有标签(按字母排序,不按时间) git tag 给对应的commitId打上标签 git show 查看标签信息 git tag -a -m “desc” 创建带有说明的标签(-a指定标签名,-m指定说明文字) git tag -s -m “desc” 用PGP签名标签 git tag -d 删除标签 git push origin :refs/tags/ 删除远程标签(需要先删除本地标签) git push origin 推送标签到远程 git push origin —tags 推送所有标签到远程 忽略文件 git add -f 强制添加被.gitignore忽略不能添加的文件 git check-ignore -v 查看文件被忽略的原因 别名定义 git config —global alias.st status 配置查看仓库状态的别名 git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8新特性之Thread Sanitizer]]></title>
      <url>%2F2016%2F12%2F31%2FXcode8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BThread%20Sanitizer%2F</url>
      <content type="text"><![CDATA[多线程问题调试工具 Thread Sanitizer的使用打开Xcode 8新增的多线程问题调试工具Thread Sanitizer 运行下图中代码，检测data race很直观，Xcode直接提示你发生了data race的变量及其代码位置，同时还清晰的展示了函数当前的各线程调用栈，十分清晰，接下来你要做的就是增加同步操作，比如加锁，从而消除data race，再运行测试是否生效。 最后计算的结果有很大概率小于20000，原因是count ++为非原子操作。这也是data race的场景，这种race没有crash也没有memory corruption，因此有些人把这种race称作benign race(良性的race)。不过上面提到的WWDC视频中，苹果的工程师说到：There is No Such Thing as a “Benign” Race意思是，只要发生data race，就没有良性一说了，因为虽然程序没有crash，但count最后的值还是出错了，这种 错误必然会导致逻辑上的错误，如果这个count值代表的是你银行卡余额，你应该会更加同意苹果工程师的观点。 data race定义： 当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race Thread Sanitizer的工作原理 在WWDC的视频中也介绍过了，大家可以仔细看下视频，大致原理是记录每个线程访问变量的信息来做分析，值得一提的是，现阶段的Thread Sanitizer最多只同时记录4个线程的访问信息，在复杂的场景下，可能出现偶尔检测不出data race的场景，所以需要长时间经常性的运行来尽可能多的发现data race，这也是为什么苹果建议默认开启Thread Sanitizer，而且Thread Sanitizer造成的额外性能损耗非常之小。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS并发编程(Concurrent Programming)上]]></title>
      <url>%2F2016%2F12%2F22%2FiOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(Concurrent%20Programming)%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[多线程和GCD 术语进程(process): 正在运行中的程序(可执行文件)称为进程 拥有独立的虚拟内存空间和系统资源，包括端口权限等 当一个进程的主线程退出时，这个进程就结束了 线程(thread): 线程是进程中一个独立的代码执行路径(控制单元) 一个进程中至少包含一条线程，即主线程（又叫UI线程） 可以将耗时的执行路径(如：网络请求)放在其他线程中执行 在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads 任务(task): 需要执行的工作，是一个抽象的概念 通俗的说，就是一段代码 队列(queue): 串行队列，队列中的任务只会顺序执行 并行队列，队列中的任务通常会并发执行 iOS 系统就是使用队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。 同步和异步: 串行与并行针对的是队列，而同步与异步，针对的则是线程。 最大的区别在于，同步操作要阻塞当前线程，必须要等待同步操作中的任务执行完，返回以后，才能继续执行下一任务；而异步操作则是不用等待 并发(concurrent)： 同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。 调度原理 多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将短暂的时间片(Timeslice)分配给每一个线程轮流使用CPU 由于CPU对每个时间片的处理速度非常快, 因此，用户看来好像这些任务在同时执行的 如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。 多线程优势、弊端和误区优势: 充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态 将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好 当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整 弊端: 新建线程会消耗内存空间和CPU时间，线程太多会降低系统的运行性能 误区: 多线程技术是为了并发执行多项任务，不会提高单个算法本身的执行效率 iOS的三种多线程技术NSThreadNSThread 是 Objective-C 对 pthread 的一个封装。 使用NSThread对象建立一个线程非常方便 但是！要使用NSThread管理多个线程非常困难，不推荐使用 技巧！使用[NSThread currentThread]跟踪任务所在线程(包括GCD和Operation Queues) GCD为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。 是基于C语言的底层API 用Block定义任务，使用起来非常灵活便捷 提供了更多的控制能力以及操作队列中所不能使用的底层函数 Operation Queues操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。 是使用GCD实现的一套Objective-C的API 是面向对象的多线程技术 提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系 NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。12[NSOperationQueue mainQueue] //获取主队列NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //自定义队列 主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。 Grand Central Dispatch（GCD）GCD的基本思想是就将操作放在队列中去执行 操作使用Blocks定义队列负责调度操作执行所在的线程以及具体的执行时间队列的特点是先进先出(FIFO)的，新添加至队列的操作都会排在队尾 提示: GCD的函数都是以dispatch开头的 操作: dispatch_async 异步操作 dispatch_sync 同步操作 注： 队列不是线程？也不表示对应的CPU 队列就是负责调度的! 谁空闲，就把任务给谁！ 多线程技术的目的，就是为了在一个CPU上实现快速切换！ GCD队列(dispatch_queue_t)GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。 无论什么队列和什么任务，线程的创建和回收不需要程序员参与。线程的创建回收工作是由队列负责的“并发”编程，为了让程序员从负责的线程控制中解脱出来！只需要面对队列和任务！ GCD串行队列12345678910111213dispatch_queue_t q = dispatch_queue_create("com.name.s", DISPATCH_QUEUE_SERIAL);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建线程, 任务顺序执行(非常有用)for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD并行队列12345678910111213dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建多个线程, 任务无序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD全局队列全局队列与并行队列的区别: 不需要创建，直接GET就能用 两个队列的执行效果相同 全局队列没有名称，调试时，无法确认准确队列 强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，造成优先级反转，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。 12345678910111213dispatch_queue_t q =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建多个线程, 任务无序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD主队列在iOS开发中，所有UI的更新工作，都必须在主线程上执行！1234567891011dispatch_queue_t q = dispatch_get_main_queue();//同步操作会造成死锁,永远不会执行dispatch_sync(q, ^&#123;NSLog(@"come here baby!");&#125;);// 异步操作，在主线程上运行，同时是保持队形的for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ - %d", [NSThread currentThread], i);&#125;);&#125; GCD不同队列种嵌套dispatch_sync的结果123456789101112131415// 全局队列，都在主线程上执行，不会死锁dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 并行队列，都在主线程上执行，不会死锁dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);// 串行队列，会死锁，但是会执行嵌套同步操作之前的代码dispatch_queue_t q = dispatch_queue_create("com.name.s", DISPATCH_QUEUE_SERIAL);// 直接死锁dispatch_queue_t q = dispatch_get_main_queue();dispatch_sync(q, ^&#123;NSLog(@"同步任务 %@", [NSThread currentThread]);dispatch_sync(q, ^&#123;NSLog(@"同步任务 %@", [NSThread currentThread]);&#125;);&#125;); dispatch_sync的应用场景: 阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录 确保块代码之外的局部变量确实被修改 GCD死锁这里有篇博客已经介绍得非常详细了,图文并茂, 浅显易懂某妹纸博客 GCD队列组（Group queue） Group queue 可以通过调用dispatch_group_create()来获取，通过dispatch_group_notify,可以直接监听组里所有线程完成情况。 当遇到需要执行多个线程并发执行，然后等多个线程都结束之后，再汇总执行结果时可以用group queue 1234567891011121314dispatch_queue_t q = dispatch_get_global_queue(0, 0);dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_group_t groupQueue = dispatch_group_create();NSLog(@"current task");dispatch_group_async(groupQueue, q, ^&#123;NSLog(@"并行任务1");&#125;);dispatch_group_async(groupQueue, q, ^&#123;NSLog(@"并行任务2");&#125;);dispatch_group_notify(groupQueue, mainQueue, ^&#123;NSLog(@"groupQueue中的任务 都执行完成,回到主线程更新UI");&#125;);NSLog(@"next task"); GCD常用系统方法dispatch_once 保证在app运行期间，block中的代码只执行一次 经典使用场景－－－单例 12345678910+ (instancetype)manager &#123;static id instance = nil;// 使用GCDstatic dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 保证代码执行一次instance = [[[self class] alloc]init];&#125;);return instance;&#125; dispatch_after 延时添加到队列 1234567891011dispatch_time_t delayTime3 = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);dispatch_time_t delayTime2 = dispatch_time(DISPATCH_TIME_NOW, 2*NSEC_PER_SEC);dispatch_queue_t mainQueue = dispatch_get_main_queue();NSLog(@"current task");dispatch_after(delayTime3, mainQueue, ^&#123;NSLog(@"3秒之后添加到队列");&#125;);dispatch_after(delayTime2, mainQueue, ^&#123;NSLog(@"2秒之后添加到队列");&#125;);NSLog(@"next task"); dispatch_apply 在给定的队列上多次执行某一任务 是同步执行的函数, 在主线程直接调用会阻塞主线程去执行block中的任务 一般把dispatch_apply放在异步队列中调用，然后执行完成后通知主线程 12345678910111213141516dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);NSLog(@"current task");dispatch_async(globalQueue, ^&#123;dispatch_queue_t applyQueue = dispatch_get_global_queue(0, 0);// 3表示重复次数dispatch_apply(3, applyQueue, ^(size_t index) &#123;NSLog(@"current index %@",@(index));sleep(1);&#125;);NSLog(@"dispatch_apply 执行完成");dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_async(mainQueue, ^&#123;NSLog(@"回到主线程更新UI");&#125;);&#125;);NSLog(@"next task"); dispatch_barrier_async 栅栏的作用 功能：在并行队列中，等待在dispatch_barrier_async之前加入队列的任务全部执行完成之后，再执行dispatch_barrier_async中的任务，再去执行在dispatch_barrier_async之后加入到队列中的任务。 12345678910dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);dispatch_async(q, ^&#123;NSLog(@"dispatch 1");&#125;);dispatch_barrier_async(q, ^&#123;NSLog(@"dispatch barrier");&#125;);dispatch_async(q, ^&#123;NSLog(@"dispatch 2");&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8如何使用插件]]></title>
      <url>%2F2016%2F12%2F21%2FXcode8.1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[Xcode8安装插件 1.安装苹果官方Xcode82.在Finder应用程序中将Xcode8复制一份(打包上架使用)3.打开钥匙串访问4.填写如图 第一行名称填写XcodeSigner第二行不变第三行选代码签名 5.终端运行(要等10多分钟,固态硬盘会快一些)sudo codesign -f -s XcodeSigner /Applications/Xcode.app 6.这时你可以安装Alcatraz了github地址 本人使用如下的终端命令来安装Alcatraz:curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh如果你不想使用Alcatraz了,可以使用如下命令来删除:rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin删除所有通过Alcatraz安装的安装包rm -rf ~/Library/Application\ Support/Alcatraz/ 7.Xcode 插件升级失效解决办法 使用以下终端命令获取DVTPlugInCompatibilityUUID字段defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID将XXXX替换成刚刚获取的DVTPlugInCompatibilityUUIDfind ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add XXXX 8.打开一个Xcode project, 选择load bundle,再次打开工程,已经可以愉快的使用插件了. 参考文章:http://www.cocoachina.com/bbs/read.php?tid=1705417]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发布框架到cocoapods]]></title>
      <url>%2F2016%2F12%2F20%2F%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B%E5%88%B0cocoapods%2F</url>
      <content type="text"><![CDATA[让自己的框架支持cocoapods 在github建立仓库,并clone到本地github不是唯一的平台,其他平台都可以,前提是项目是开源的. 创建.podspec文件打开终端,进入仓库,执行如下命令: pod spec create XXX 编辑.podspec文件使用vim或Xcode打开.podspec文件,编辑如下:123456789101112131415Pod::Spec.new do |s|s.name = "XXX"s.version = "1.0.3"s.ios.deployment_target = '8.0's.summary = "some utilities"s.homepage = "https://github.com/weixinbing/XXX"s.license = &#123; :type =&gt; "MIT", :file =&gt; "LICENSE" &#125;s.author = &#123; "weixb" =&gt; "183292352@qq.com" &#125;s.social_media_url = "http://weibo.com/u/5348162268"s.source = &#123; :git =&gt; "https://github.com/weixinbing/XXX.git", :tag =&gt; s.version &#125;s.source_files = "XXX"s.requires_arc = trues.dependency "YTKNetwork", "~&gt; 2.0.3"s.dependency 'Bugly', '~&gt; 2.4.2'end s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错s.version：版本号s.ios.deployment_target:支持的pod最低版本s.summary: 简介s.homepage:项目主页地址s.license:许可证s.author:作者s.social_media_url:社交网址s.source:项目的地址s.source_files:需要包含的源文件s.resources: 资源文件s.requires_arc: 是否支持ARCs.dependency：依赖库(可以多写) source_files:写法及含义: “”XXX”和“XXX/” 表示匹配所有文件(不包含文件夹)“XXX/.{h,m}” 表示匹配所有以.h和.m结尾的文件(不包含文件夹)“XXX/**” 表示匹配所有子目录(不包含文件夹) 验证本地仓库.podspec文件 pod lib lint XXX.podspec 上传本地仓库到Git给仓库打上tag git tag ‘1.0.0’ //第一步git push origin –tags //推送到远程仓库 验证远程仓库.podspec文件 pod spec lint XXX.podspec 发布发布前先验证是否已注册trunk： pod trunk me 没有注册则使用命令： pod trunk register Email “Name” –verbose注册完成之后会给你的邮箱发个邮件,进入邮箱邮件里面有个链接,需要点击确认一下 已注册则执行发布命令： pod trunk push XXX.podspec 发布成功就可以使用pod导入你的框架了。 错误搜集遇到错误CocoaPods was not able to update the master repo. If this is an unexpected issue and persists you can inspect it running pod repo update --verbose执行命令pod repo update即可 发布成功,执行pod search XXX搜索 遇到错误Unable to find a pod with name, author, summary, or descriptionmatching “XXX”的解决方法: 方法1:使用终端命令rm ~/Library/Caches/CocoaPods/search_index.json 删除cocoapods本地缓存,再使用pod search XXX搜索.方法2:使用终端命令pod setup 更新cocoapods的repo,再重复方法1. 依赖错误, 可以使用 –use-libraries 来让验证通过.警告错误, 可以使用 –allow-warnings 来让验证通过.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YYModel,MJExtension,JSONModel对比]]></title>
      <url>%2F2016%2F12%2F20%2FYYModel%2CMJExtension%2CJSONModel%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[JSON模型 使用区别 JSONModel要求所有模型类必须继承自JSONModel基类YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 量级上 YYModel和MJExtension都是超轻量级框架YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高. 字典和模型之间互相转换 MJExtension支持:Plist –&gt; Model Array1模型数组 = [模型类名 objectArrayWithFilename:@"文件名.plist"]; JSON Array –&gt; Model Array1NSArray *modelArray = [模型类名 objectArrayWithKeyValuesArray:字段数组]; JSONString –&gt; Model ArrayModel Array –&gt; JSON ArrayYYModel没有看到对字典数组和模型数组相互转换的支持 容器类属性 YYModel需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)objectClassInArray &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension可以配合ESJsonFormat模型插件使用,插件自动实现容器方法.YYModel也可以配合ESJsonFormat模型插件使用,需要修改容器实现的方法名. JSONModel是最简单的,只需要参照以下写法即可1@property (nonatomic) NSArray &lt;ProductModel&gt; *products; 归档和解档 三者性能相当MJExtension只需要一行代码调用写好的宏MJExtensionCodingImplementation就可以实现YYModel需要遵守NSCoding协议,并重写下面方法12- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder]; &#125; 日志 MJExtension只需要在@implementation 和 @end之间写上宏MJLogAllIvrs,就能解决调试时，打印模型，只打印出内存地址的问题YYModel需要重写description方法1- (NSString *)description &#123; return [self yy_modelDescription]; &#125; 模型中的属性名和字典中的key不相同(或者需要多级映射) YYModel需要在 @implementation 和 @end之间 写上1234567+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"name" : @"n", @"page" : @"p", @"desc" : @"ext.desc", @"bookID" : @[@"id",@"ID",@"book_id"] &#125;;&#125; MJExtension需要在转换代码之前实现12345678910[Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123; return @&#123; @"ID" : @"id", @"desc" : @"desciption", @"oldName" : @"name.oldName", @"nowName" : @"name.newName", @"nameChangedTime" : @"name.info[1].nameChangedTime", @"bag" : @"other.bag" &#125;;&#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC预处理指令]]></title>
      <url>%2F2016%2F12%2F19%2FOC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[深入了解预处理指令 预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。指令用途：12345678910#空指令，无任何效果#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if 如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息 文件包含#include预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。 宏宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。 #运算符出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：12345#definePASTE(n)"adhfkj"#nmain()&#123;printf("%s ",PASTE(15));&#125; 宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。 ##运算符用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：12345678910#defineNUM(a,b,c)a##b##c#defineSTR(a,b,c)a##b##cmain()&#123;printf("%d ",NUM(1,2,3));printf("%s ",STR("aa","bb","cc"));&#125;最后程序的输出为:123aabbcc1 条件编译指令条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。 #if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。 #endif指令用于终止#if预处理指令。 #ifdef和#ifndef用于#define命令定义过则进行编译 #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。 #elif指令综合了#else和#if指令的作用。 其他一些标准指令 #error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。 补充：预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。 情况112345#ifdef _XXXX...程序段1...#else...程序段2...#endif 这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。 情况212345#ifndef _XXXX ...程序段1... #else ...程序段2... #endif 这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。 情况312345#if 常量 ...程序段1...#else...程序段2...#endif 这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 结合 Github 搭建的博客]]></title>
      <url>%2F2016%2F12%2F18%2FHexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[博客是怎样搭建的 配置环境 安装Node.js 官网https://nodejs.org/en/ 安装Git（Xcode自带有Git） 注册GitHub账号（用于博客的远程仓库） 安装Hexo打开终端，执行命令： npm install hexo-cli -g 如果报错，加上sudo。hexo常用命令：12345hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章hexo clean #清除生成的文件 初始化博客文件夹hexo init [文件夹名字] cd [文件夹名字] npm install 成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： http://localhost:4000 ： hexo s 如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试： npm install hexo-server --save 编辑hexo的配置文件不要被文件内容吓到了，只需要修改以下地方：1234567# Sitetitle: xxxsubtitle: xxxdescription: xxxauthor: xxxlanguage: zh-Hanstimezone: Asia/Shanghai 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github仓库的克隆地址 branch: master 部署通常情况下是先生成网站，然后部署。可以将两个步骤放到一起： hexo d -g 现在你就可以打开网站看到效果了。如果提示： ERROR Deployer not found:git 需要要安装hexo-deployer-git： npm install hexo-deployer-git --save 完成后执行部署命令hexo d -g。 发布通过以下命令新建文章： hexo new “文章名字&quot; 然后用编辑器打开 source_posts 里的md文件编辑。更新文章： hexo d -g 这样就可以把你的新文章传上去啦。 主题NexT 官方WiKiNexT 官方网站]]></content>
    </entry>

    
  
  
</search>
