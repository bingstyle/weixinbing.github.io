<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[发布框架到cocoapods]]></title>
      <url>%2F2016%2F12%2F20%2F%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B%E5%88%B0cocoapods%2F</url>
      <content type="text"><![CDATA[在github建立仓库,并clone到本地github不是唯一的平台,其他平台都可以,前提是项目是开源的. 创建.podspec文件打开终端,进入仓库,执行如下命令: pod spec create XXX 编辑.podspec文件使用vim或Xcode打开.podspec文件,编辑如下:123456789101112131415Pod::Spec.new do |s|s.name = "XXX"s.version = "1.0.3"s.ios.deployment_target = '8.0's.summary = "some utilities"s.homepage = "https://github.com/weixinbing/XXX"s.license = &#123; :type =&gt; "MIT", :file =&gt; "LICENSE" &#125;s.author = &#123; "weixb" =&gt; "183292352@qq.com" &#125;s.social_media_url = "http://weibo.com/u/5348162268"s.source = &#123; :git =&gt; "https://github.com/weixinbing/XXX.git", :tag =&gt; s.version &#125;s.source_files = "XXX"s.requires_arc = trues.dependency "YTKNetwork", "~&gt; 2.0.3"s.dependency 'Bugly', '~&gt; 2.4.2'end s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错s.version：版本号s.ios.deployment_target:支持的pod最低版本s.summary: 简介s.homepage:项目主页地址s.license:许可证s.author:作者s.social_media_url:社交网址s.source:项目的地址s.source_files:需要包含的源文件s.resources: 资源文件s.requires_arc: 是否支持ARCs.dependency：依赖库(可以多写) source_files:写法及含义: “”XXX”和“XXX/” 表示匹配所有文件(不包含文件夹)“XXX/.{h,m}” 表示匹配所有以.h和.m结尾的文件(不包含文件夹)“XXX/**” 表示匹配所有子目录(不包含文件夹) 验证本地仓库.podspec文件 pod lib lint XXX.podspec 上传本地仓库到Git给仓库打上tag git tag ‘1.0.0’ //第一步git push origin –tags //推送到远程仓库 验证远程仓库.podspec文件 pod spec lint XXX.podspec 发布发布前先验证是否已注册trunk： pod trunk me 没有注册则使用命令： pod trunk register Email “Name” –verbose注册完成之后会给你的邮箱发个邮件,进入邮箱邮件里面有个链接,需要点击确认一下 已注册则执行发布命令： pod trunk push XXX.podspec 发布成功就可以使用pod导入你的框架了。 错误搜集遇到错误CocoaPods was not able to update the master repo. If this is an unexpected issue and persists you can inspect it running pod repo update --verbose执行命令pod repo update即可 发布成功,执行pod search XXX搜索 遇到错误Unable to find a pod with name, author, summary, or descriptionmatching “XXX”的解决方法: 方法1:使用终端命令rm ~/Library/Caches/CocoaPods/search_index.json 删除cocoapods本地缓存,再使用pod search XXX搜索.方法2:使用终端命令pod setup 更新cocoapods的repo,再重复方法1. 依赖错误, 可以使用 –use-libraries 来让验证通过.警告错误, 可以使用 –allow-warnings 来让验证通过.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YYModel,MJExtension,JSONModel对比]]></title>
      <url>%2F2016%2F12%2F20%2FYYModel%2CMJExtension%2CJSONModel%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[使用区别 JSONModel要求所有模型类必须继承自JSONModel基类YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 量级上 YYModel和MJExtension都是超轻量级框架YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高. 字典和模型之间互相转换 MJExtension支持:Plist –&gt; Model Array1模型数组 = [模型类名 objectArrayWithFilename:@"文件名.plist"]; JSON Array –&gt; Model Array1NSArray *modelArray = [模型类名 objectArrayWithKeyValuesArray:字段数组]; JSONString –&gt; Model ArrayModel Array –&gt; JSON ArrayYYModel没有看到对字典数组和模型数组相互转换的支持 容器类属性 YYModel需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)objectClassInArray &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension可以配合ESJsonFormat模型插件使用,插件自动实现容器方法.YYModel也可以配合ESJsonFormat模型插件使用,需要修改容器实现的方法名. JSONModel是最简单的,只需要参照以下写法即可1@property (nonatomic) NSArray &lt;ProductModel&gt; *products; 归档和解档 三者性能相当MJExtension只需要一行代码调用写好的宏MJExtensionCodingImplementation就可以实现YYModel需要遵守NSCoding协议,并重写下面方法12- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder]; &#125; 日志 MJExtension只需要在@implementation 和 @end之间写上宏MJLogAllIvrs,就能解决调试时，打印模型，只打印出内存地址的问题YYModel需要重写description方法1- (NSString *)description &#123; return [self yy_modelDescription]; &#125; 模型中的属性名和字典中的key不相同(或者需要多级映射) YYModel需要在 @implementation 和 @end之间 写上1234567+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"name" : @"n", @"page" : @"p", @"desc" : @"ext.desc", @"bookID" : @[@"id",@"ID",@"book_id"] &#125;;&#125; MJExtension需要在转换代码之前实现12345678910[Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123; return @&#123; @"ID" : @"id", @"desc" : @"desciption", @"oldName" : @"name.oldName", @"nowName" : @"name.newName", @"nameChangedTime" : @"name.info[1].nameChangedTime", @"bag" : @"other.bag" &#125;;&#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC预处理命令]]></title>
      <url>%2F2016%2F12%2F19%2FOC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。指令用途：12345678910#空指令，无任何效果#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if 如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息 文件包含#include预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。 宏宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。 #运算符出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：12345#definePASTE(n)"adhfkj"#nmain()&#123;printf("%s ",PASTE(15));&#125; 宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。 ##运算符用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：12345678910#defineNUM(a,b,c)a##b##c#defineSTR(a,b,c)a##b##cmain()&#123;printf("%d ",NUM(1,2,3));printf("%s ",STR("aa","bb","cc"));&#125;最后程序的输出为:123aabbcc1 条件编译指令条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。 #if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。 #endif指令用于终止#if预处理指令。 #ifdef和#ifndef用于#define命令定义过则进行编译 #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。 #elif指令综合了#else和#if指令的作用。 其他一些标准指令 #error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。 补充：预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。 情况112345#ifdef _XXXX...程序段1...#else...程序段2...#endif 这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。 情况212345#ifndef _XXXX ...程序段1... #else ...程序段2... #endif 这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。 情况312345#if 常量 ...程序段1...#else...程序段2...#endif 这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 结合 Github 搭建的博客]]></title>
      <url>%2F2016%2F12%2F18%2FHexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[配置环境 安装Node.js 官网https://nodejs.org/en/ 安装Git（Xcode自带有Git） 注册GitHub账号（用于博客的远程仓库） 安装Hexo打开终端，执行命令： npm install hexo-cli -g 如果报错，加上sudo。hexo常用命令：12345hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章hexo clean #清除生成的文件 初始化博客文件夹hexo init [文件夹名字] cd [文件夹名字] npm install 成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： http://localhost:4000 ： hexo s 如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试： npm install hexo-server --save 编辑hexo的配置文件不要被文件内容吓到了，只需要修改以下地方：1234567# Sitetitle: xxxsubtitle: xxxdescription: xxxauthor: xxxlanguage: zh-Hanstimezone: Asia/Shanghai 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github仓库的克隆地址 branch: master 部署通常情况下是先生成网站，然后部署。可以将两个步骤放到一起： hexo d -g 现在你就可以打开网站看到效果了。如果提示： ERROR Deployer not found:git 需要要安装hexo-deployer-git： npm install hexo-deployer-git --save 完成后执行部署命令hexo d -g。 发布通过以下命令新建文章： hexo new “文章名字&quot; 然后用编辑器打开 source_posts 里的md文件编辑。更新文章： hexo d -g 这样就可以把你的新文章传上去啦。 主题NexT 官方WiKi]]></content>
    </entry>

    
  
  
</search>
