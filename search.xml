<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[官方 Swift API 设计指南（译）]]></title>
      <url>%2F2018%2F10%2F10%2F22%20%5B%E8%AF%91%5D%20%E5%AE%98%E6%96%B9%20Swift%20API%20%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[原文：Swift API Design Guidelines 其他：Google Swift Style Guide （中文版） 基本原则 使用时能够清晰表达设计者的意图，是最重要的目标。做出 API 设计、声明后要检查在上下文中是否足够清晰明白。 清晰比简洁重要。虽然 swift 代码可以被写得很简短，但是让代码尽量少不是 swift 的目标。简洁的代码来源于安全、强大的类型系统和其他一些语言特性减少了不必要的模板代码。而不是主观上写出最少的代码。 为每个API添加注释。添加注释有助于加深对API的理解，从而其设计产生深远影响。所以，别犯懒 如果您无法用简单的术语描述API的功能，那么您可能设计了错误的API。 使用Swift的Markdown。 首先描述要声明的实体的摘要。通常，API可以从其声明及其摘要中完全理解。 123/// Returns a "view" of `self` containing the same elements in/// reverse order.func reversed() -&gt; ReverseCollection 专注于总结 ; 这是最重要的部分。许多优秀的文档注释只包含一个很棒的摘要。 如果可能，使用单个句子片段，以句点结束。不要使用完整的句子。 描述函数或方法的**作用**和 返回的内容，省略null效果并Void返回： 12345678910/// Inserts `newHead` at the beginning of `self`.mutating func prepend(_ newHead: Int)/// Returns a `List` containing `head` followed by the elements/// of `self`.func prepending(_ head: Element) -&gt; List/// Removes and returns the first element of `self` if non-empty;/// returns `nil` otherwise.mutating func popFirst() -&gt; Element? 注意：在popFirst上述极少数情况下，摘要由分号分隔的多个句子片段组成。 描述下标**访问的内容**： 描述初始化程序**创建的内容**： 对于所有其他声明，请描述声明的实体**是**什么。 继续使用一个或多个段落和项目符号项。段落用空行分隔并使用完整的句子（可选）。 1234567891011121314/// 将`items`中每个元素的文字表示写入标准输出。////// 每个元素`x`的文字表示通过表达式`String(x)`生成。///////// - 参数 separator: 两项之间的文字/// - 参数 terminator: 末尾的文字////// - 注意: 想要省略末尾的换行符，为`terminator`传入""////// - 其他参考: `CustomDebugStringConvertible`, `CustomStringConvertible`, `debugPrint`。public func print( _ items: Any..., separator: String = " ", terminator: String = "\n") 在适当的时候，使用已识别的 符号文档标记 元素在摘要之外添加信息 使用符号命令语法了解并使用已识别的项目 符号。流行的开发工具（如Xcode）对以下列关键字开头的项目符号进行特殊处理： | Attention | Author | Authors | Bug || ———- | ————- | ———— | ———- || Complexity | Copyright | Date | Experiment || Important | Invariant | Note | Parameter || Parameters | Postcondition | Precondition | Remark || Requires | Returns | SeeAlso | Since || Throws | ToDo | Version | Warning | 命名意图清晰 保证命名让使用的人不会产生歧义 比如在集合中有一个方法，根据给定的位置移除元素： 12345✅extension List &#123; public mutating func remove(at position: Index) -&gt; Element&#125;employees.remove(at: x) 如果在方法签名中省略了at，用户在使用的时候就会以为这是删除一个等于 x 的元素，而不是移除索引在 x 的元素： 12❌employees.remove(x) // 不够清晰: 这里感觉像是移除 x 省略无用的词。命名中的每一个单词都应该有意义。 准确传达意图，消除歧义，意味着更多的单词；然而，携带重复信息的冗余单词，应该省略。特别是那些单纯重复类型信息的词语。 1234❌public mutating func removeElement(_ member: Element) -&gt; Element?allViews.removeElement(cancelButton) 上面的代码中，Element在未提供任何有效信息。这个API应修改为： 1234✅public mutating func remove(_ member: Element) -&gt; Element?allViews.remove(cancelButton) // 更清晰 根据变量，参数，关联类型的角色为其命名，而非类型。 12345678❌var string = "Hello"protocol ViewController &#123; associatedtype ViewType : View&#125;class ProductionLine &#123; func restock(from widgetFactory: WidgetFactory)&#125; 以这种方式再次说明类型的名称并没有让代码更清晰、更富有表现力。但是如果选择用实体承担的角色命名则会好的多。 12345678✅var greeting = "Hello"protocol ViewController &#123; associatedtype ContentView : View&#125;class ProductionLine &#123; func restock(from supplier: WidgetFactory)&#125; 如果一个 associatedtype 的角色和类型刚好一样，请通过附加Protocol到协议名称来避免冲突 ： 1234protocol Sequence &#123; associatedtype Iterator : IteratorProtocol&#125;protocol IteratorProtocol &#123; ... &#125; 为弱类型添加补充信息，明确参数的作用。 尤其是当参数类型为，Any，AnyObject，或诸如Int或String这样的基础类型时，仅靠上下文和类型信息可能不足以传达意图。例如，下面的代码中，方法声明看起来意图还算清晰，但实际使用时却不是这样。 1234❌func add(_ observer: NSObject, for keyPath: String)grid.add(self, for: graphics) 为了能够重新表达清晰，在每个弱类型参数前加一个名词描述它的角色： 123✅func addObserver(_ observer: NSObject, forKeyPath path: String)grid.addObserver(self, forKeyPath: graphics) // clear 让代码更加流畅 尽量让方法、函数名使用的时候代码语句接近正常的语法。 1234✅x.insert(y, at: z) “x, insert y at z”x.subViews(havingColor: y) “x's subviews having color y”x.capitalizingNouns() “x, capitalizing nouns” 1234❌x.insert(y, position: z)x.subViews(color: y)x.nounCapitalize() 为了流畅度把后面的和方法名相关弱的参数换行也是可以接受的： 123AudioUnit.instantiate( with: description, options: [.inProcess], completionHandler: stopProgressBar) 如果是创建型的工厂方法，用 “make” 开头。比如：x.makeIterator()。 调用构造函数和工厂方法时，组成的短语不包含第一个参数名。例如，x.makeWidget(cogCount: 47)。 例如，下面的情况第一个参数命名时都不需要考虑作为一个句子的部分： 1234✅let foreground = Color(red: 32, green: 64, blue: 128)let newPart = factory.makeWidget(gears: 42, spindles: 14)let ref = Link(target: destination) 如果为了句子的连贯性就会声明成下面这样（但是并不推荐这样做）： 1234❌let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)let ref = Link(to: destination) 实际上，此准则以及参数标签的准则 意味着第一个参数将具有标签，除非调用执行的是值保留类型转换。 1let rgbForeground = RGBColor(cmykForeground) 函数、方法命名时要参考自身的副作用。 没有副作用的名字读起来应该像一个名词的短语。比如： x.distance(to: y), i.successor()。 有副作用的读起来应该是一个祈使式的动词短语，比如：print(x), x.sort(), x.append(y)。 可变/不可变方法的命名要成对出现。一个可变方法通常都有一个不可变方法与之对应，二者的语义相近，区别在于前者直接更新实例，后者返回一个新值。 如果描述操作的是一个动词，使用动词的祈使态表示 mutating，nonmutating 在动词后加上 “ed” 或 “ing” 表示。 | 可变方法 | 不可变方法 || ————- | ——————– || x.sort() | z = x.sorted() || x.append(y) | z = x.appending(y) | 当一项操作恰好能够被一个名词描述时，使用名词为不可变方法命名；加前缀”form”，为可变方法命名。 | 不可变方法 | 可变方法 || ——————– | ——————— || x = y.union(z) | y.formUnion(z) || j = c.successor(i) | c.formSuccessor(&amp;i) | 作为不可变方法，如果返回布尔值的方法或属性，读起来应该像是对被调用对象的断言。例如，x.isEmpty，line1.intersects(line2)。 表示是什么的 Protocol 读起来应该是一个名词。比如：Collection。 表示能力的 Protocol 后缀应该用 able、ible 或者 ing 修饰。比如：Equatable, ProgressReporting。 其他形式的类型、属性、变量、常量都应该用名词命名。 慎用术语 Term of Art 名词 - 在某个领域或行业内，有着明确特殊含义的词或短语。 避免使用晦涩的术语，特别是如果有一个常见词汇能够表达同样意义时。例如，如果”皮肤“能够满足表述需求，就不要使用“表皮”。术语是重要的交流工具，但应该仅在其他表述方式会丢失关键意义时使用。 如果使用术语，严格的使用术语本来的含义。 使用技术术语的原因就是它比常用的词语能够更精确的表达含义，因此 API 应该严格按照其公认的含义使用术语。 不要让专家感到惊讶：如果这个词出现在熟悉它的人面前，他还会觉得惊讶说明这个词的含义很可能被歪曲了。 不要让新手感到迷茫：任何一个人如果想要了解这个术语通过一个普通的网络搜索就应该能够查到它的含义。 避免使用缩写。尤其是非标准的缩写。非标准的缩略语可能无法被其他人正确的理解。 使用的任何缩写的意思都应该很容易通过网络搜索查到。 遵循先例。不用因为新手的理解成本而改变原有用法。 例如，最好将一个连续的数据结构命名为Array，而非更简单的List，虽然对于新手来说，后者的含义更容易掌握。数组是现代计算机科学的基础数据结构，所以每个程序员都知道——或者很快就会学到——什么是数组。使用大多数程序员所熟悉的术语，这样，即便有问题，互联网和其他人也能够提供帮助。 在某些特定的编程领域，例如数学， 诸如sin(x)这样已经广为人们所接受的术语，要比诸如verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)这样解释性的命名好的多。注意，这里先例打破了避免缩写的规则：尽管单词的完整拼写是sine，但”sin(x)”已经被程序员使用了数十年，在数学中更是数百年。 约定通用约定 对于复杂度不是O(1)的计算型属性，要通过注释特别说明。人们总是认为属性访问不牵扯大量计算，因为访问的是实例变量（存储型属性）。当这个惯例被打破时，有必要提醒他们。 优先选择方法或属性，而非函数。后者只在下述情况中使用： 使用时不需要 self 存在： 1min(x, y, z) 不限制类型的函数： 1print(x) 函数的使用方式已经是一个习惯用法： 1sin(x) 遵守大小写的惯例类型和协议的命名首字母大写，其他的都是首字母小写。 美式英语中首字母通常以大写出现的缩略词的所有字母大小写保持一致： 123var utf8Bytes: [UTF8.CodeUnit]var isRepresentableAsASCII = truevar userSMTPServer: SecureSMTPServer 其他情况的缩略词当做普通单词处理： 12var radarDetector: RadarScannervar enjoysScubaDiving = true 当方法共享相同的基本含义或在不同的域中操作时，方法可以共享基本名称。 下面这种方式是被鼓励的，因为所有的方法的目的都是一样的： 1234567891011✅extension Shape &#123; /// Returns `true` iff `other` is within the area of `self`. func contains(_ other: Point) -&gt; Bool &#123; ... &#125; /// Returns `true` iff `other` is entirely within the area of `self`. func contains(_ other: Shape) -&gt; Bool &#123; ... &#125; /// Returns `true` iff `other` is within the area of `self`. func contains(_ other: LineSegment) -&gt; Bool &#123; ... &#125;&#125; 因为几何类型和集合也是不同的领域，所有下面这样定义也是可以的： 123456✅extension Collection where Element : Equatable &#123; /// Returns `true` iff `self` contains an element equal to /// `sought`. func contains(_ sought: Element) -&gt; Bool &#123; ... &#125;&#125; 下面例子中的 index 则有不同的含义，所以应该有不同的命名： 12345678❌extension Database &#123; /// Rebuilds the database's search index func index() &#123; ... &#125; /// Returns the `n`th row in the given table. func index(_ n: Int, inTable: TableID) -&gt; TableRow &#123; ... &#125;&#125; 最后，避免方法只有返回类型不同，这会影响系统的类型推断。 12345678910❌extension Box &#123; /// Returns the `Int` stored in `self`, if any, and /// `nil` otherwise. func value() -&gt; Int? &#123; ... &#125; /// Returns the `String` stored in `self`, if any, and /// `nil` otherwise. func value() -&gt; String? &#123; ... &#125;&#125; 参数（Parameters）1func move(from start: Point, to end: Point) 选择参数名称以提供文档。即使参数名称在函数或方法调用时没有出现，它们也起着重要的解释作用。 选择能够提升文档可读性的名称。下面的例子中，参数名使得文档读起来自然流畅： 123456✅/// 返回一个`Array`，包含`self`中所有满足`predicate`的元素func filter(_ predicate: (Element) -&gt; Bool) -&gt; [Generator.Element]/// 将给定的`subRange`中的元素替换为`newElements`mutating func replaceRange(_ subRange: Range, with newElements: [E]) 而下面的文档读起来很别扭，不符合语言习惯： 123456❌/// 返回一个`Array`，包含`self`中所有满足`includedInResult`的元素func filter(_ includedInResult: (Element) -&gt; Bool) -&gt; [Generator.Element]/// 将`r`所指代的范围内的元素替换为`with`中的内容mutating func replaceRange(_ r: Range, with: [E]) 利用默认参数简化用例。如果参数有一个常用值，就可以为其提供一个默认参数。 通过隐藏无关信息，默认参数能够提升可读性。例如： 12❌let order = lastName.compare(royalFamilyName, options [], range: nil, locale: nil) 通过默认参数，化繁为简： 12✅let order = lastName.compare(royalFamilyName) 默认参数通常适用于方法族， 大大减轻了理解API的负担。 1234✅extension String &#123; public func compare (_ other: String, options: CompareOptions = [], range: Range? = nil, locale: Locale? = nil) -&gt; Ordering&#125; 上述方法看起来可能没那么简单，但它比以下简单得多： 1234567891011121314❌extension String &#123; /// ...description 1... public func compare(_ other: String) -&gt; Ordering /// ...description 2... public func compare(_ other: String, options: CompareOptions) -&gt; Ordering /// ...description 3... public func compare( _ other: String, options: CompareOptions, range: Range) -&gt; Ordering /// ...description 4... public func compare( _ other: String, options: StringCompareOptions, range: Range, locale: Locale) -&gt; Ordering&#125; 每个方法都要分开注释；为了选择使用哪一个，用户必须全部理解，并搞清它们之间的关系。有时，这些关系让人感到诧异，例如foo(bar: nil)和foo()的作用并不总是相同——试图在文档中寻找这种微妙区别会变是很恶心的。利用默认参数，简化为一个方法，极大提升了用户体验。 将具有默认参数的参数项放到方法最后。从语义上来说，没有默认参数的参数项对于方法来说更为重要，并且可以在调用时提供稳定的格式。 参数标签（Argument Labels）12func move(from start: Point, to end: Point)x.move(from: x, to: y) 如果不需要区分参数，则可以省略所有实参标签。例如：min(number1, number2), zip(sequence1, sequence2)。 如果构造函数进行的是值保留类型转换操作，则省略第一个实参标签。例如：Int64(someUint32)。 第一个参数应该始终是转换的数据源。 123456789extension String &#123; // Convert `x` into its textual representation in the given radix init(_ x: BigInt, radix: Int = 10) ← Note the initial underscore&#125;text = "The value is: "text += String(veryLargeNumber)text += " and in hexadecimal, it's"text += String(veryLargeNumber, radix: 16) 而对于“值省略类型转换”来说，最好使用第一个标签描述所省略的内容。 123456789extension UInt32 &#123; /// Creates an instance having the specified `value`. init(_ value: Int16) ← Widening, so no label /// Creates an instance having the lowest 32 bits of `source`. init(truncating source: UInt64) /// Creates an instance having the nearest representable /// approximation of `valueToApproximate`. init(saturating valueToApproximate: UInt64)&#125; 值保留类型转换是单态，即一个值对应一个结果。例如，将一个Int8值转换为一个Int64值属于这种操作，因为不同的Int8值都对应不同的Int64值。反过来就不是：Int64可能的值要比Int8能够表示的值多得多。 注意：能否追溯原始值，同是不是值保留类型转换没有联系。 当第一个参数构成介词短语的一部分时 ，给它一个参数标签。参数标签通常应该以介词开头 ，例如x.removeBoxes(havingLength: 12)。 有一种例外是前两个或多个参数共同组成一个抽象概念。 123❌a.move(toX: b, y: c)a.fade(fromRed: b, green: c, blue: d) 这时，将介词提前，放在方法名中，概念会更清晰。 123✅a.moveTo(x: b, y: c)a.fadeFrom(red: b, green: c, blue: d) 否则，如果第一个参数构成语法短语的一部分，则省略其标签，将任何前面的单词附加到基本名称，例如x.addSubview(y) 本规则意味着如果第一个参数不组成任何短语，应该给其加上标签。 1234✅view.dismiss(animated: false)let text = words.split(maxSplits: 12)let studentByName = students.sorted(isOrderedBefore: Student.namePrecedes) 请注意，短语传达正确的含义非常重要。下述短语的含义错误。 123❌view.dismiss(false) // 不要dismiss？还是dismiss一个布尔值？words.split(12) // 查分一个数字12？ 另外，有默认值的参数可以省略，因此这些参数不参与短语的组成，所以它们总是有标签。 其他参数都需要加上标签。 特殊说明 如果API使用使用了闭包和元组，则为闭包参数和元组成员添加标签。 这些标签具有解释作用，可以在编写注释时引用，还可以用来访问元组成员。 123456789101112/// 确保至少分配了`requestedCapacity`个元素的存储空间。////// 如果需要更多存储空间，`allocate`会被调用，分配`byteCount`个最大对齐字节。/// /// - 返回/// - reallocated: 当且仅当新的内存非配成功，返回`true`/// - capacityChanged: 当且仅当`capacity`被更新时，返回`true`mutating func ensureUniqueStorage( minimumCapacity requestedCapacity: Int, allocate: (_ byteCount: Int) -&gt; UnsafePointer&lt;Void&gt;) -&gt; (reallocated: Bool, capacityChanged: Bool) 闭包参数的命名规则和正常的函数参数规则一样，但是参数标签还不支持闭包。 使用弱类型时，避免重载产生歧义。例如，Any，AnyObject及不受限的范型参数。 考虑如下一组重载方法： 12345678❌struct Array &#123; /// 在`self.endIndex`中插入`newElement`。 public mutating func append(_ newElement: Element) /// 将`newElements`中的内容按序插入`self.endIndex`中。 public mutating func append(_ newElement: S) where S.Generator.Element == Element&#125; 这些方法从语义上构成一个方法族，参数的类型乍一看也有很大区别。但是，如果Element的类型是Any，那么一个Element就和一组Element有着相同的类型（即一个和一组都是Any）。 123❌var values: [Any] = [1, "a"]values.append([2, 3, 4]) // 结果是[1, "a", [2, 3, 4]]还是[1, "a", 2, 3, 4]？ 为了消除歧义，重新命名第二个方法，赋予其更多含义。 12345678✅struct Array &#123; /// 在`self.endIndex`中插入`newElement`。 public mutating func append(_ newElement: Element) /// 将`newElements`中的内容按序插入`self.endIndex`中。 public mutating func append(contentsOf newElement: S) where S.Generator.Element == Element&#125; 注意第二个方法的实参标签是如何同文档呼应的。这时，通过书写文档，API设计者能够注意到潜在的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS端mPaaS框架]]></title>
      <url>%2F2018%2F06%2F18%2F21%20iOS%E7%AB%AFmPaaS%E8%B0%83%E7%A0%94%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[配置开发环境流程：按照官方文档配置流程，本人最开始使用的.org的ruby源，导致后面安装开发者工具报错，更新为.com后环境配置一路顺畅。流程如下： 检查 RubyGems 源 公告！因域名备案问题，.org域名无法继续提供RubyGems镜像服务，我们提供.com代替.org的域名，其它一切不变 $ gem sources –add https://gems.ruby-china.com/ –remove https://rubygems.org/ $ gem sources -l #确保只有 gems.ruby-china.com 升级 RubyGems $ sudo gem update –system 安装 Ruby2.2.4使用rvm工具管理ruby版本，如果安装了多个版本，设置Ruby 2.2.4 为默认版本 $ rvm use 2.2.4 –default 安装开发者工具 完全退出 Xcode，在终端运行下列安装命令： $ sh &lt;(curl -s http://mpaas-ios.oss-cn-hangzhou.aliyuncs.com/mPaaS-Install-Tool/installmPaaS.sh ) 对于 Xcode 8 之后的版本，安装 mPaaS 插件时需要 unsign Xcode。按照提示输入 U。脚本会自动完成安装。 去除Xcode签名 $ mpaas unsign 恢复Xcode签名 $ mpaas restore 更新所有 Xcode 插件的 UUID $ mpaas update_plugins 安装命令行工具（可选） 更新到最新版的开发者工具 $ mpkitupdate 打印出本地的 SDK 里模块的信息 $ mpaas sdk 更新本地SDK $ mpaas sdk update 创建工程基于 mPaaS 框架开发按照官方文档流程接入正常 基于系统框架开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mail邮箱管理]]></title>
      <url>%2F2018%2F03%2F21%2F20%20Mail%E9%82%AE%E7%AE%B1%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[添加账号QQ邮箱登录QQ邮箱网页版，点击设置-&gt;账号-&gt;POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 开启IMAP/SMTP服务 协议 服务器地址 POP3 pop.qq.com IMAP imap.qq.com SMTP smtp.qq.com QQ企业邮箱 协议 服务器地址 POP3 pop.exmail.qq.com IMAP imap.exmail.qq.com SMTP smtp.exmail.qq.com 阿里云邮箱 协议 服务器地址 服务器端口号（常规） 服务器端口号（加密） POP3 pop.qiye.aliyun.com 110 995 IMAP imap.qiye.aliyun.com 143 993 SMTP smtp.qiye.aliyun.com 25 465 参考：关于邮箱的POP协议、imap协议、imap协议简单讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac代理设置-Proxifier]]></title>
      <url>%2F2018%2F03%2F21%2F19%20Mac%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE-Proxifier%2F</url>
      <content type="text"><![CDATA[Proxifier下载 设置代理服务器 步骤如下： shdowsocks的端口默认1080（自定义shdowsocks端口的需要修改） 设置代理规则方案1：设置全局代理 方案2：设置部分代理 参考来源：一言以蔽之，如果你在终端中发起了网络请求速度很慢的话，可以先把 default 规则，设置为socks5代理（只有设置为代理，日志才会记录），然后分析一下请求的 host：port，然后就可以添加规则了，这样的话，就做到只给部分请求走代理，如果你觉得这样很麻烦， 也可以简单粗暴的，将 default 规则设置为 socks5代理，其余的规则全部禁用，那就是全部的请求走代理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[科学上网]]></title>
      <url>%2F2018%2F03%2F20%2F18%20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
      <content type="text"><![CDATA[1. 安装shadowsocksshadowsocks下载链接 Shadowsocks Windows 使用说明 2. 购买VPS推荐搬瓦工，稳定、性价比高（20美元/年） 搬瓦工VPS 3. VPS搭建Shadowsocks从搬瓦工管理页面进入控制面板，步骤如下： 方法1：找到左侧的Shadowsocks server，点击安装（该功能若未显示，可使用方法2） 方法2：在浏览器输入链接打开界面后点击安装 安装成功后如下： 代理设置1、2、3步骤完成后浏览器就可以科学上网了 终端翻墙：使用shadowsocks翻墙]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ipa重签名的三种方法]]></title>
      <url>%2F2017%2F09%2F09%2F17%20ipa%E9%87%8D%E7%AD%BE%E5%90%8D%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[一、sigh resign 安装 sigh 命令：[sudo] gem install sigh 安装 fastlane 命令：[sudo] gem install fastlane -NV 第一步，把 ipa 包和下载的描述文件 XXX.mobileprovison 放在同级目录下 第二步，终端 cd 到这个 ipa 的文件夹目录下，执行 sigh resign 或者 fastlane sigh resign 命令 第三步：输入 Signing Identity (证书的十六进制串) 二、iOS App Signer下载 GitHub 上的源码运行 第一项，填写要重签名的 ipa 路径，第二项，选择新签名的证书，第三项，选择下载的描述文件 provisoning profile（默认项 Re-Sign Only 是无效的） 点击 star 三、iResign (不推荐)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zsh安装和配置]]></title>
      <url>%2F2017%2F09%2F02%2F16%20zsh%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[zsh官网 zsh安装安装命令终端运行（需翻墙）： sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 配置文件编辑配置文件vim ~/.zshrc 修改主题：ZSH_THEME=”ys” 重新载入源文件source ~/.zshrc 插件安装brew install zsh-autosuggestions brew install zsh-syntax-highlighting vim ~/.zshrc 然后G 切换到末行 添加 source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zshsource /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 快捷键⌃ + u：清空当前行 ⌃ + a：移动到行首 ⌃ + e：移动到行尾 ⌃ + f：向前移动 ⌃ + b：向后移动 ⌃ + p：上一条命令 ⌃ + n：下一条命令 ⌃ + r：搜索历史命令 ⌃ + y：召回最近用命令删除的文字 ⌃ + h：删除光标之前的字符 ⌃ + d：删除光标所指的字符 ⌃ + w：删除光标之前的单词 ⌃ + k：删除从光标到行尾的内容 ⌃ + t：交换光标和之前的字符 ⌘ + d：上下分屏 ⇧⌘ + d：关闭上下分屏 为什么说 zsh 是 shell 中的极品？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS自动化部署和发布之Fastlane]]></title>
      <url>%2F2017%2F07%2F20%2F15%20iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%92%8C%E5%8F%91%E5%B8%83%E4%B9%8BFastlane%2F</url>
      <content type="text"><![CDATA[Fastlane 官方文档：https://docs.fastlane.tools/ 安装确保安装了最新版本的Xcode命令行工具： xcode-select –install 安装fastlane： 使用gem命令安装[sudo] gem install fastlane -NV使用brew命令安装brew cask install fastlane cd到工程所在目录下执行： fastlane init 插件安装 firim插件fastlane add_plugin firim蒲公英插件fastlane add_plugin pgyer ####文件配置 Appfile Appfile用来配置一些类似于AppleID、BundleID参数(参数是fastlane已经定义好的，新增的并没有用，可以在Fastfile中使用，AppleID、BundleID等其实会被一些actions直接调用，并不需要写出来传递。 1234567891011# 默认配置app_identifier ""apple_id ""team_id ""# 如果lane是test换成Dev的配置for_lane :test do app_identifier "" apple_id "" team_id ""end Fastfile Fastfile包含分发您的应用程序所需的所有信息。可以在before_all、after_all、error中做一些操作以建立一些lane作为关键的执行逻辑，可以在其中使用fastlane内置的action，也可以调用自建action，还可以调用别的lane。123456789101112131415161718192021222324default_platform(:ios)platform :ios do desc "Description of what the lane does" lane :test_firim do # add actions here: https://docs.fastlane.tools/actions build_app( workspace: "xxx.xcworkspace", scheme: "xxx", export_method: "enterprise", configuration: "Debug",# Defaults to 'Release' output_directory: "./build", output_name: "xxx", ) firim(firim_api_token: "") #上传ipa到fir.im服务器 end desc "Push a new release build to the App Store" lane :appstore do build_app(workspace: "xxx.xcworkspace", scheme: "xxx") upload_to_app_store end end 执行 fastlane test_firim]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-单例]]></title>
      <url>%2F2017%2F07%2F15%2F13%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[Objective-C 1234567891011121314151617181920212223242526272829303132/** * 分析代码: 利用了static关键字,这样以来该变量就会一直存储在静态区的,和系统同生共死. 利用gcd保证 instance = [[self alloc] init];这句代码只会执行一次,也就说明该对象一旦创建出来,就不会被重新创建 */static id instance; // 单例（全局变量）/** 单例方法 */+ (instancetype)shared&lt;#Class#&gt; &#123; // 使用GCD确保只进行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc] init]; &#125;); return instance;&#125;/** alloc 会调用allocWithZone方法 */+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; // 使用GCD确保只进行一次 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [super allocWithZone:zone]; &#125;); return instance;&#125;/** copy在底层 会调用copyWithZone方法 */- (id)copyWithZone:(struct _NSZone *)zone &#123; return instance;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[View层代码结构规范]]></title>
      <url>%2F2017%2F07%2F10%2F12%20View%E5%B1%82%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[针对View层的架构设计，还是要做好三点： 代码规范 架构模式 工具集 View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。各自实现或者使用CocoaPods里现成的都不是很难。 关于View的代码规范目的: 提高业务方View层的可读性可维护性 防止业务代码对架构产生腐蚀 保持架构发展的方向不轻易被不合理的意见所左右 确保传承 1234567891011121314151617181920212223#pragma mark - Init/* init, dealloc */#pragma mark - Life cycle- (void)viewDidLoad &#123; [super viewDidLoad]; &#125;#pragma mark - Delegate#pragma mark - Event response/* 所有button、gestureRecognizer的响应事件都放在这个区域里面 */#pragma mark - Private methods/* 关于private methods，正常情况下ViewController里面不应该写, 要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。*/#pragma mark - Getters and setters 在viewDidload里面只做addSubview的事情在viewDidAppear里面做Notification的监听之类的事情在updateViewConstraints里面做add constraints的事情属性的初始化，则交给getter去做每一个delegate都把对应的protocol名字带上所有button、gestureRecognizer的响应事件都放在Event response这个区域里面 关于View的布局苹果文档中指出，updateViewConstraints是用来做add constraints的地方。建议使用Masonry，代码的可读性就能好很多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS项目的目录结构]]></title>
      <url>%2F2017%2F07%2F10%2F11.0%20iOS%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[目录结构一个合理的目录结构首先应该是清晰的，让人一眼看上去就能大概了解目录的职责，且容易应对新的变化。 AppDelegate目录下放AppDelegate.h(.m)文件，是整个应用的入口文件，所以单独拿出来 Sections目录下放app的具体模块，如登录、设置等 General目录下放会被重用的Views、Macro和Categories等 Macro目录下放了整个应用会用到的宏定义 AppMacro.h UtilsMacro.h VendorMacro.h NotificationMacro.h AppMacro.h 里放app相关的宏定义 UtilsMacro.h 里放一些方便使用的宏定义 VendorMacro.h 里放一些第三方常量 NotificationMacro.h 里放通知相关的宏定义 Helpers目录放一些助手类，文件名与功能挂钩 Resources目录放app会用到的一些资源，主要是图片 Vendors目录放第三方的类库/SDK]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[写一个iOS应用之前必须做的事]]></title>
      <url>%2F2017%2F06%2F30%2F11%20%E5%86%99%E4%B8%80%E4%B8%AAiOS%E5%BA%94%E7%94%A8%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E5%81%9A%E7%9A%84%E4%BA%8B%2F</url>
      <content type="text"><![CDATA[为工程设置编码风格规范 在写代码之前确定应用的架构 确定应用的目录结构 项目依赖管理 为工程设置编码风格规范编码规范能够保证代码更加统一、更易于阅读和维护 可以设置自己的编码风格，但是必须保证同组的人遵守相同的规范 确定应用的架构使用传统的MVC架构，或者使用更加流行的MVVM或VIPER架构 在同一个应用中包含着多种架构。比如，你开始的时候使用MVC，突然意识到一个页面(如：列表)在MVC模式下的变得越来越难以维护，然后就切换到MVVM架构，但是仅仅针对这一个页面。并没有必要对哪些MVC模式下运转良好的页面进行重构，因为二者是可以并存的。 确定目录结构看起来是件小的事情，却可以使你的项目更加有条理且易于理解。 项目依赖管理CocoaPods一般用于Objective-C项目 Carthage一般用于Swift项目 iOS中MVC划分的正确姿势M应该做的事： 给ViewController提供数据 给ViewController存储数据提供接口 提供经过抽象的业务基本组件，供Controller调度 C应该做的事： 管理View Container的生命周期 负责生成所有的View实例，并放入View Container 监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。 V应该做的事： 响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。 界面元素表达 ViewController代码结构： #pragma mark - 生命周期 #pragma mark - initialize #pragma mark - 私有方法 #pragma mark - 重写方法 #pragma mark - 事件响应方法 #pragma mark - 系统协议 #pragma mark - 自定义协议 #pragma mark - setter #pragma mark - getter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象原则（SOLID）]]></title>
      <url>%2F2017%2F06%2F29%2F10%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99%EF%BC%88SOLID%EF%BC%89%2F</url>
      <content type="text"><![CDATA[单一功能原则 （Single Responsiblity Principle SRP） 开闭原则（Open Closed Principle，OCP 里氏替换原则（Liskov Substitution Principle，LSP） 接口隔离原则（Interface Segregation Principle，ISP） 依赖倒置原则（Dependency Inversion Principle，DIP） 迪米特法则（Law of Demeter，LOD，也叫最小知识原则） 设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。 单一功能原则规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖） 开闭原则就是说模块应对扩展开放，而对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。 开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。 里氏替换原则子类override方法的访问权限不能小于父类对应方法的访问权限。可以说：里氏代换原则是继承复用的一个基础。 接口隔离原则客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上 依赖倒置原则A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。 B.抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 迪米特法则一个软件实体应当尽可能少的与其他实体发生相互作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac工具箱]]></title>
      <url>%2F2017%2F05%2F13%2F09%20Mac%E5%B7%A5%E5%85%B7%E7%AE%B1%2F</url>
      <content type="text"><![CDATA[Alfred Alfred是我见过的最能将Mac的效率使用到极致的工具了。小到翻译一个英文单词，搜索一个文件，大到用一个命令完成本地开发环境的部署启动，都可以通过Alfred来完成。你可以将大部分的重复劳动让Alfred来帮助你完成。 Sketch 3 一款UI设计工具。Sketch只有几十M，相较于Photoshop,它小巧得多，更重要的是它是专为UI设计而生的，我不必关注那些与我做UI设计毫无关系的图片处理功能，从而降低了工作环境中的噪音。另外，通过强大的插件功能，我能根据需要进行安装使用，这大大提高了我的工作效率。 PaintCode 你可以使用PaintCode方便地进行图形设计，你也可以将SVG或PSD文件导入到PaintCode中，然后它就能帮助你将你的设计转换成Objective-C,Swift或C#代码。 Sip for Mac and iPhone Sip是一个非常出色的iOS app，它能帮助你从照片中创建色板。并且你可以在你的Mac或手机上随时随地使用它捕捉那些美丽的色彩。 Sublime Text 3 这是我开发前端代码时 使用的IDE。我非常喜欢它的那些使代码异常清晰的主题，以及功能丰富的插件。有了它开发HTML、CSS、JavaScript变成了一件非常愉悦的事情。 Dash Dash对开发人员非常有帮助，我能够在离线的状态下查看如Angular，Swift，CSS等的技术文档。这使得我在网络条件不好的情况下也能工作，并且极大提升我的工作效率。 CheatSheet CheatSheet是我非常喜欢的一个小工具，任何流行的软件都会有一堆的快捷键设置，通过这个工具，你只需要长按?键，这个软件的所有快捷键就会显示在你的面前，你完全不用逐一去背，只要反复查看几次，你自然就能熟练运用那些快捷键了。 Fantastical 我使用Fantastical来快速地记录我的todo事项，并设定提醒。我只记录那些比较重要的事项，而不会每天把所有很细小的行动项都记录下来，因为那样反而会让我有一种压迫感而分心。我更喜欢在自然舒缓的环境中工作。 LiceCap 这使一个很小的免费软件，你可以在屏幕上设定一个区域，然后就可以用LiceCap来快速地录制GIF动画了。直接、高效是我对它的评价。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git命令大全]]></title>
      <url>%2F2017%2F01%2F19%2F08%20Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[Git Command 创建仓库 git init 创建git仓库 添加提交 git add 添加(从工作区到暂存区,可多次使用添加多个文件) git commit -m “description” 提交(从暂存区到本地仓库) 查看信息 git status 查看仓库当前状态 git diff 查看添加前修改的内容 git diff HEAD — 查看工作区和版本库最新版本的区别 git log 查看提交日志 git log —pretty=oneline 查看提交日志(单行显示每一条日志) 版本回退 git reset —hard HEAD^ 回滚到上个版本 git reset —hard HEAD^^ 回滚到上上个版本 git reset —hard HEAD~n 回滚到上n个版本 git reset —hard 回滚到指定提交id的版本 撤销修改 rm 删除工作区文件 git checkout — 撤销(丢弃)工作区的修改(让工作区和HEAD保持一致) git reset HEAD 撤销暂存区的文件(个人理解为撤销git add命令) git rm 从版本库中删除文件(会同时删除工作区文件,个人理解为rm 命令 + git add 命令 ) 远程仓库 git remote add origin 关联远程仓库 git push -u origin master 第一次推送master分支的所有内容 git push origin master 推送master分支的所有内容(origin为远程库) git pull —rebase origin master 拉取master分支的内容 git pull 拉取关联的远程分支内容 git branch —set-upstream branch-name origin/branch-name 设置本地分支和远程分支的链接关系**分割线** git clone 克隆远程仓库 分支管理 git branch dev 创建一个dev分支 git checkout dev 切换到dev分支 git checkout -b dev 创建一个dev分支并切换到dev分支 git checkout -b dev origin/dev 创建远程origin的dev分支到本地 git branch 查看分支(列出所有分支,当前分支前有*标记) git merge dev 合并指定分支到当前分支 git merge —no-ff -m “desc” dev 合并dev分支到当前分支并禁用”fast forward” git branch -d dev 删除dev分支 git branch -D dev 强行删除一个没有被合并过的dev分支**分割线** git log —graph 查看分支的合并情况 git log —graph —pretty=oneline 查看分支的合并情况(单行) git log —graph —pretty=oneline —abbrev-commit 查看分支的合并情况(单行短id) 贮藏管理 git stash 贮藏当前工作区的修改(可多次stash) git stash list 查看贮藏列表 git stash apply 恢复stash内容(不删除stash内容) git stash drop 删除stash内容 git stash pop 恢复并删除stash内容 标签管理 git tag 给当前分支上最新的的commitId打上标签 git tag 查看所有标签(按字母排序,不按时间) git tag 给对应的commitId打上标签 git show 查看标签信息 git tag -a -m “desc” 创建带有说明的标签(-a指定标签名,-m指定说明文字) git tag -s -m “desc” 用PGP签名标签 git tag -d 删除标签 git push origin :refs/tags/ 删除远程标签(需要先删除本地标签) git push origin 推送标签到远程 git push origin —tags 推送所有标签到远程 忽略文件 git add -f 强制添加被.gitignore忽略不能添加的文件 git check-ignore -v 查看文件被忽略的原因 别名定义 git config —global alias.st status 配置查看仓库状态的别名 git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8新特性之Thread Sanitizer]]></title>
      <url>%2F2016%2F12%2F31%2F07%20Xcode8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BThread%20Sanitizer%2F</url>
      <content type="text"><![CDATA[多线程问题调试工具 Thread Sanitizer的使用打开Xcode 8新增的多线程问题调试工具Thread Sanitizer 运行下图中代码，检测data race很直观，Xcode直接提示你发生了data race的变量及其代码位置，同时还清晰的展示了函数当前的各线程调用栈，十分清晰，接下来你要做的就是增加同步操作，比如加锁，从而消除data race，再运行测试是否生效。 最后计算的结果有很大概率小于20000，原因是count ++为非原子操作。这也是data race的场景，这种race没有crash也没有memory corruption，因此有些人把这种race称作benign race(良性的race)。不过上面提到的WWDC视频中，苹果的工程师说到：There is No Such Thing as a “Benign” Race意思是，只要发生data race，就没有良性一说了，因为虽然程序没有crash，但count最后的值还是出错了，这种 错误必然会导致逻辑上的错误，如果这个count值代表的是你银行卡余额，你应该会更加同意苹果工程师的观点。 data race定义： 当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race Thread Sanitizer的工作原理 在WWDC的视频中也介绍过了，大家可以仔细看下视频，大致原理是记录每个线程访问变量的信息来做分析，值得一提的是，现阶段的Thread Sanitizer最多只同时记录4个线程的访问信息，在复杂的场景下，可能出现偶尔检测不出data race的场景，所以需要长时间经常性的运行来尽可能多的发现data race，这也是为什么苹果建议默认开启Thread Sanitizer，而且Thread Sanitizer造成的额外性能损耗非常之小。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中的关键字const／static／extern]]></title>
      <url>%2F2016%2F12%2F26%2F06.0%20iOS%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97const%EF%BC%8Fstatic%EF%BC%8Fextern%2F</url>
      <content type="text"><![CDATA[const:const只修饰其右边的变量，被修饰的变量是只读的；const常量不能被修改，不能用来定义数组的长度，也不能放在case关键字后面。123456789101112const int *pint const *p // *p只读, p变量(这2种没有区别)int * const p // *p变量, p只读const int * const p // *p只读, p只读int const * const p // *p只读, p只读 const常量误区： const int n = 5; int a[n]; 上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是“常量”，而数组定义时长度必须是“常量”，因此报错。 const int MAX_LENGTH = 100; //这不是“常量”，而是一个只读变量。 static1. 修饰局部变量保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存， 生命周期类似全局变量了，但是作用域不变。 2. 修饰全局变量使全局变量的作用域仅限于当前文件内部，不能通过extern来引用 3. 修饰函数被修饰的函数被称为静态函数，使得外部文件无法访问这个函数，OC语言中很少使用。 extern它的作用是声明外部全局变量 苹果推荐extern声明全局变量（不建议使用define），优势是保持常量绝对不会被修改，并且还带有初始化的类型信息。通常在.h中声明，在.m中实现12345// .h声明extern NSString * const NAME;// .m实现NSString * const NAME = @"XXX"; const是用来定义一个常量。而static在C语言中（OC中延用）表明此变量只在该变量的输出文件中可用(.m文件)，如果你不加“static”符号，那么编译器就会对该变量创建一个“外部符号”，后果是什么呢？ 你可以尝试在不同文件中加入以下代码：NSString * const kUserName = @&quot;StrongX&quot;;可能尽管文件之间并没有相互引用，不存在属性名重复的问题（因为这并不是一个属性，这是一个外部符号）,但是编译器还是报错了:duplicate symbol XXX in: .... clang: error: linker command failed with exit code 1 (use -v to see invocation) 它会告诉你在两个目标文件(.o文件是.m文件编译后的输出文件)有一个重复的符号。(OC中没有类似C++中的名字空间的概念)所以当你在你自己的.m文件中需要声明一个只有你自己可见的局部变量(k开头)的变量的时候一定要同时使用“static”和“const”两个关键字。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS并发编程(Concurrent Programming)]]></title>
      <url>%2F2016%2F12%2F22%2F06%20iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(Concurrent%20Programming)%E4%B8%8A%2F</url>
      <content type="text"><![CDATA[多线程和GCD 术语进程(process): 正在运行中的程序(可执行文件)称为进程 拥有独立的虚拟内存空间和系统资源，包括端口权限等 当一个进程的主线程退出时，这个进程就结束了 线程(thread): 线程是进程中一个独立的代码执行路径(控制单元) 一个进程中至少包含一条线程，即主线程（又叫UI线程） 可以将耗时的执行路径(如：网络请求)放在其他线程中执行 在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads 任务(task): 需要执行的工作，是一个抽象的概念 通俗的说，就是一段代码 队列(queue): 串行队列，队列中的任务只会顺序执行 并行队列，队列中的任务通常会并发执行 iOS 系统就是使用队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。 同步和异步: 串行与并行针对的是队列，而同步与异步，针对的则是线程。 最大的区别在于，同步操作要阻塞当前线程，必须要等待同步操作中的任务执行完，返回以后，才能继续执行下一任务；而异步操作则是不用等待 并发(concurrent)： 同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。 调度原理 多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将短暂的时间片(Timeslice)分配给每一个线程轮流使用CPU 由于CPU对每个时间片的处理速度非常快, 因此，用户看来好像这些任务在同时执行的 如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。 多线程优势、弊端和误区优势: 充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态 将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好 当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整 弊端: 新建线程会消耗内存空间和CPU时间，线程太多会降低系统的运行性能 误区: 多线程技术是为了并发执行多项任务，不会提高单个算法本身的执行效率 iOS的三种多线程技术NSThreadNSThread 是 Objective-C 对 pthread 的一个封装。 使用NSThread对象建立一个线程非常方便 但是！要使用NSThread管理多个线程非常困难，不推荐使用 技巧！使用[NSThread currentThread]跟踪任务所在线程(包括GCD和Operation Queues) GCD为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。 是基于C语言的底层API 用Block定义任务，使用起来非常灵活便捷 提供了更多的控制能力以及操作队列中所不能使用的底层函数 Operation Queues操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。 是使用GCD实现的一套Objective-C的API 是面向对象的多线程技术 提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系 NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。12[NSOperationQueue mainQueue] //获取主队列NSOperationQueue *queue = [[NSOperationQueue alloc] init]; //自定义队列 主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。 Grand Central Dispatch（GCD）GCD的基本思想是就将操作放在队列中去执行 操作使用Blocks定义队列负责调度操作执行所在的线程以及具体的执行时间队列的特点是先进先出(FIFO)的，新添加至队列的操作都会排在队尾 提示: GCD的函数都是以dispatch开头的 操作: dispatch_async 异步操作 dispatch_sync 同步操作 注： 队列不是线程？也不表示对应的CPU 队列就是负责调度的! 谁空闲，就把任务给谁！ 多线程技术的目的，就是为了在一个CPU上实现快速切换！ GCD队列(dispatch_queue_t)GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。 无论什么队列和什么任务，线程的创建和回收不需要程序员参与。线程的创建回收工作是由队列负责的“并发”编程，为了让程序员从负责的线程控制中解脱出来！只需要面对队列和任务！ GCD串行队列12345678910111213dispatch_queue_t q = dispatch_queue_create("com.name.s", DISPATCH_QUEUE_SERIAL);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建线程, 任务顺序执行(非常有用)for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD并行队列12345678910111213dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建多个线程, 任务无序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD全局队列全局队列与并行队列的区别: 不需要创建，直接GET就能用 两个队列的执行效果相同 全局队列没有名称，调试时，无法确认准确队列 强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，造成优先级反转，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。 12345678910111213dispatch_queue_t q =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//同步操作不会新建线程, 任务顺序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_sync(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125;//异步操作会新建多个线程, 任务无序执行for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ %d", [NSThread currentThread], i);&#125;);&#125; GCD主队列在iOS开发中，所有UI的更新工作，都必须在主线程上执行！1234567891011dispatch_queue_t q = dispatch_get_main_queue();//同步操作会造成死锁,永远不会执行dispatch_sync(q, ^&#123;NSLog(@"come here baby!");&#125;);// 异步操作，在主线程上运行，同时是保持队形的for (int i = 0; i &lt; 10; ++i) &#123;dispatch_async(q, ^&#123;NSLog(@"%@ - %d", [NSThread currentThread], i);&#125;);&#125; GCD不同队列种嵌套dispatch_sync的结果123456789101112131415// 全局队列，都在主线程上执行，不会死锁dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 并行队列，都在主线程上执行，不会死锁dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);// 串行队列，会死锁，但是会执行嵌套同步操作之前的代码dispatch_queue_t q = dispatch_queue_create("com.name.s", DISPATCH_QUEUE_SERIAL);// 直接死锁dispatch_queue_t q = dispatch_get_main_queue();dispatch_sync(q, ^&#123;NSLog(@"同步任务 %@", [NSThread currentThread]);dispatch_sync(q, ^&#123;NSLog(@"同步任务 %@", [NSThread currentThread]);&#125;);&#125;); dispatch_sync的应用场景: 阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录 确保块代码之外的局部变量确实被修改 GCD死锁这里有篇博客已经介绍得非常详细了,图文并茂, 浅显易懂某妹纸博客 GCD队列组（Group queue） Group queue 可以通过调用dispatch_group_create()来获取，通过dispatch_group_notify,可以直接监听组里所有线程完成情况。 当遇到需要执行多个线程并发执行，然后等多个线程都结束之后，再汇总执行结果时可以用group queue 1234567891011121314dispatch_queue_t q = dispatch_get_global_queue(0, 0);dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_group_t groupQueue = dispatch_group_create();NSLog(@"current task");dispatch_group_async(groupQueue, q, ^&#123;NSLog(@"并行任务1");&#125;);dispatch_group_async(groupQueue, q, ^&#123;NSLog(@"并行任务2");&#125;);dispatch_group_notify(groupQueue, mainQueue, ^&#123;NSLog(@"groupQueue中的任务 都执行完成,回到主线程更新UI");&#125;);NSLog(@"next task"); GCD常用系统方法dispatch_once 保证在app运行期间，block中的代码只执行一次 经典使用场景－－－单例 12345678910+ (instancetype)manager &#123;static id instance = nil;// 使用GCDstatic dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 保证代码执行一次instance = [[[self class] alloc]init];&#125;);return instance;&#125; dispatch_after 延时添加到队列 1234567891011dispatch_time_t delayTime3 = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);dispatch_time_t delayTime2 = dispatch_time(DISPATCH_TIME_NOW, 2*NSEC_PER_SEC);dispatch_queue_t mainQueue = dispatch_get_main_queue();NSLog(@"current task");dispatch_after(delayTime3, mainQueue, ^&#123;NSLog(@"3秒之后添加到队列");&#125;);dispatch_after(delayTime2, mainQueue, ^&#123;NSLog(@"2秒之后添加到队列");&#125;);NSLog(@"next task"); dispatch_apply 在给定的队列上多次执行某一任务 是同步执行的函数, 在主线程直接调用会阻塞主线程去执行block中的任务 一般把dispatch_apply放在异步队列中调用，然后执行完成后通知主线程 12345678910111213141516dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);NSLog(@"current task");dispatch_async(globalQueue, ^&#123;dispatch_queue_t applyQueue = dispatch_get_global_queue(0, 0);// 3表示重复次数dispatch_apply(3, applyQueue, ^(size_t index) &#123;NSLog(@"current index %@",@(index));sleep(1);&#125;);NSLog(@"dispatch_apply 执行完成");dispatch_queue_t mainQueue = dispatch_get_main_queue();dispatch_async(mainQueue, ^&#123;NSLog(@"回到主线程更新UI");&#125;);&#125;);NSLog(@"next task"); dispatch_barrier_async 栅栏的作用 功能：在并行队列中，等待在dispatch_barrier_async之前加入队列的任务全部执行完成之后，再执行dispatch_barrier_async中的任务，再去执行在dispatch_barrier_async之后加入到队列中的任务。 12345678910dispatch_queue_t q = dispatch_queue_create("com.name.c", DISPATCH_QUEUE_CONCURRENT);dispatch_async(q, ^&#123;NSLog(@"dispatch 1");&#125;);dispatch_barrier_async(q, ^&#123;NSLog(@"dispatch barrier");&#125;);dispatch_async(q, ^&#123;NSLog(@"dispatch 2");&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8如何使用插件]]></title>
      <url>%2F2016%2F12%2F21%2F05%20Xcode8.1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[Xcode8安装插件 1.安装苹果官方Xcode82.在Finder应用程序中将Xcode8复制一份(打包上架使用)3.打开钥匙串访问4.填写如图 第一行名称填写XcodeSigner第二行不变第三行选代码签名 5.终端运行(要等10多分钟,固态硬盘会快一些)sudo codesign -f -s XcodeSigner /Applications/Xcode.app 6.这时你可以安装Alcatraz了github地址 本人使用如下的终端命令来安装Alcatraz:curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh如果你不想使用Alcatraz了,可以使用如下命令来删除:rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin删除所有通过Alcatraz安装的安装包rm -rf ~/Library/Application\ Support/Alcatraz/ 7.Xcode 插件升级失效解决办法 使用以下终端命令获取DVTPlugInCompatibilityUUID字段defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID将XXXX替换成刚刚获取的DVTPlugInCompatibilityUUIDfind ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add XXXX 8.打开一个Xcode project, 选择load bundle,再次打开工程,已经可以愉快的使用插件了. 参考文章:http://www.cocoachina.com/bbs/read.php?tid=1705417]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[发布框架到cocoapods]]></title>
      <url>%2F2016%2F12%2F20%2F04%20%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B%E5%88%B0cocoapods%2F</url>
      <content type="text"><![CDATA[让自己的框架支持cocoapods 在github建立仓库,并clone到本地github不是唯一的平台,其他平台都可以,前提是项目是开源的. 创建.podspec文件打开终端,进入仓库,执行如下命令: pod spec create XXX 编辑.podspec文件使用vim或Xcode打开.podspec文件,编辑如下:123456789101112131415Pod::Spec.new do |s|s.name = "XXX"s.version = "1.0.3"s.ios.deployment_target = '8.0's.summary = "some utilities"s.homepage = "https://github.com/weixinbing/XXX"s.license = &#123; :type =&gt; "MIT", :file =&gt; "LICENSE" &#125;s.author = &#123; "weixb" =&gt; "183292352@qq.com" &#125;s.social_media_url = "http://weibo.com/u/5348162268"s.source = &#123; :git =&gt; "https://github.com/weixinbing/XXX.git", :tag =&gt; s.version &#125;s.source_files = "XXX"s.requires_arc = trues.dependency "YTKNetwork", "~&gt; 2.0.3"s.dependency 'Bugly', '~&gt; 2.4.2'end s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错s.version：版本号s.ios.deployment_target:支持的pod最低版本s.summary: 简介s.homepage:项目主页地址s.license:许可证s.author:作者s.social_media_url:社交网址s.source:项目的地址s.source_files:需要包含的源文件s.resources: 资源文件s.requires_arc: 是否支持ARCs.dependency：依赖库(可以多写) source_files:写法及含义: “”XXX”和“XXX/” 表示匹配所有文件(不包含文件夹)“XXX/.{h,m}” 表示匹配所有以.h和.m结尾的文件(不包含文件夹)“XXX/**” 表示匹配所有子目录(不包含文件夹) 验证本地仓库.podspec文件 pod lib lint XXX.podspec 上传本地仓库到Git给仓库打上tag git tag ‘1.0.0’ //第一步git push origin –tags //推送到远程仓库 验证远程仓库.podspec文件 pod spec lint XXX.podspec 发布发布前先验证是否已注册trunk： pod trunk me 没有注册则使用命令： pod trunk register Email “Name” –verbose注册完成之后会给你的邮箱发个邮件,进入邮箱邮件里面有个链接,需要点击确认一下 已注册则执行发布命令： pod trunk push XXX.podspec 发布成功就可以使用pod导入你的框架了。 错误搜集遇到错误CocoaPods was not able to update the master repo. If this is an unexpected issue and persists you can inspect it running pod repo update --verbose执行命令pod repo update即可 发布成功,执行pod search XXX搜索 遇到错误Unable to find a pod with name, author, summary, or descriptionmatching “XXX”的解决方法: 方法1:使用终端命令rm ~/Library/Caches/CocoaPods/search_index.json 删除cocoapods本地缓存,再使用pod search XXX搜索.方法2:使用终端命令pod setup 更新cocoapods的repo,再重复方法1. 依赖错误, 可以使用 –use-libraries 来让验证通过.警告错误, 可以使用 –allow-warnings 来让验证通过.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YYModel,MJExtension,JSONModel对比]]></title>
      <url>%2F2016%2F12%2F20%2F03%20YYModel%2CMJExtension%2CJSONModel%E5%AF%B9%E6%AF%94%2F</url>
      <content type="text"><![CDATA[JSON模型 使用区别 JSONModel要求所有模型类必须继承自JSONModel基类YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性 量级上 YYModel和MJExtension都是超轻量级框架YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高. 字典和模型之间互相转换 MJExtension支持:Plist –&gt; Model Array1模型数组 = [模型类名 objectArrayWithFilename:@"文件名.plist"]; JSON Array –&gt; Model Array1NSArray *modelArray = [模型类名 objectArrayWithKeyValuesArray:字段数组]; JSONString –&gt; Model ArrayModel Array –&gt; JSON ArrayYYModel没有看到对字典数组和模型数组相互转换的支持 容器类属性 YYModel需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension需要在 @implementation 和 @end之间 写上123+ (NSDictionary *)objectClassInArray &#123; return @&#123;@"arrayName" : [模型类名 class]&#125;;&#125; MJExtension可以配合ESJsonFormat模型插件使用,插件自动实现容器方法.YYModel也可以配合ESJsonFormat模型插件使用,需要修改容器实现的方法名. JSONModel是最简单的,只需要参照以下写法即可1@property (nonatomic) NSArray &lt;ProductModel&gt; *products; 归档和解档 三者性能相当MJExtension只需要一行代码调用写好的宏MJExtensionCodingImplementation就可以实现YYModel需要遵守NSCoding协议,并重写下面方法12- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [self yy_modelEncodeWithCoder:aCoder]; &#125;- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super init]; return [self yy_modelInitWithCoder:aDecoder]; &#125; 日志 MJExtension只需要在@implementation 和 @end之间写上宏MJLogAllIvrs,就能解决调试时，打印模型，只打印出内存地址的问题YYModel需要重写description方法1- (NSString *)description &#123; return [self yy_modelDescription]; &#125; 模型中的属性名和字典中的key不相同(或者需要多级映射) YYModel需要在 @implementation 和 @end之间 写上1234567+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@"name" : @"n", @"page" : @"p", @"desc" : @"ext.desc", @"bookID" : @[@"id",@"ID",@"book_id"] &#125;;&#125; MJExtension需要在转换代码之前实现12345678910[Student mj_setupReplacedKeyFromPropertyName:^NSDictionary *&#123; return @&#123; @"ID" : @"id", @"desc" : @"desciption", @"oldName" : @"name.oldName", @"nowName" : @"name.newName", @"nameChangedTime" : @"name.info[1].nameChangedTime", @"bag" : @"other.bag" &#125;;&#125;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC预处理指令]]></title>
      <url>%2F2016%2F12%2F19%2F02%20OC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[深入了解预处理指令 预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。指令用途：12345678910#空指令，无任何效果#include包含一个源代码文件#define定义宏#undef取消已定义的宏#if 如果给定条件为真，则编译下面代码#ifdef如果宏已经定义，则编译下面代码#ifndef如果宏没有定义，则编译下面代码#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码#endif结束一个#if……#else条件编译块#error停止编译并显示错误信息 文件包含#include预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。 宏宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。 #运算符出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：12345#definePASTE(n)"adhfkj"#nmain()&#123;printf("%s ",PASTE(15));&#125; 宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。 ##运算符用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：12345678910#defineNUM(a,b,c)a##b##c#defineSTR(a,b,c)a##b##cmain()&#123;printf("%d ",NUM(1,2,3));printf("%s ",STR("aa","bb","cc"));&#125;最后程序的输出为:123aabbcc1 条件编译指令条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。 #if指令检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。 #endif指令用于终止#if预处理指令。 #ifdef和#ifndef用于#define命令定义过则进行编译 #else指令用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。 #elif指令综合了#else和#if指令的作用。 其他一些标准指令 #error指令将使编译器显示一条错误信息，然后停止编译。#line指令可以改变编译器用来指出警告和错误信息的文件号和行号。#pragma指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。 补充：预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。 情况112345#ifdef _XXXX...程序段1...#else...程序段2...#endif 这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。 情况212345#ifndef _XXXX ...程序段1... #else ...程序段2... #endif 这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。 情况312345#if 常量 ...程序段1...#else...程序段2...#endif 这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速搭建个人博客]]></title>
      <url>%2F2016%2F12%2F18%2F01%20Hexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[Hexo 结合 Github 搭建博客 配置环境 安装Node.js 官网https://nodejs.org/en/ 安装Git（Xcode自带有Git） 注册GitHub账号（用于博客的远程仓库） 安装Hexo打开终端，执行命令： npm install hexo-cli -g 如果报错，加上sudo。hexo常用命令：12345hexo g #完整命令为hexo generate,用于生成静态文件hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d #完整命令为hexo deploy,用于将本地文件发布到github上hexo n #完整命令为hexo new,用于新建一篇文章hexo clean #清除生成的文件 初始化博客文件夹hexo init [文件夹名字] cd [文件夹名字] npm install 成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： http://localhost:4000 ： hexo s 如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试： npm install hexo-server --save 编辑hexo的配置文件不要被文件内容吓到了，只需要修改以下地方：1234567# Sitetitle: xxxsubtitle: xxxdescription: xxxauthor: xxxlanguage: zh-Hanstimezone: Asia/Shanghai 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github仓库的克隆地址 branch: master 部署通常情况下是先生成网站，然后部署。可以将两个步骤放到一起： hexo d -g 现在你就可以打开网站看到效果了。如果提示： ERROR Deployer not found:git 需要要安装hexo-deployer-git： npm install hexo-deployer-git --save 完成后执行部署命令hexo d -g。 发布通过以下命令新建文章： hexo new “文章名字&quot; 然后用编辑器打开 source_posts 里的md文件编辑。更新文章： hexo d -g 这样就可以把你的新文章传上去啦。 主题NexT 官方WiKiNexT 官方网站 绑定域名现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。 以我的阿里云为例，如下图所示，添加两条解析记录： 记录类型 主机记录 解析线路(isp) 记录值 MX优先级 TTL 状态 CNAME @ 默认 weixinbing.github.io – 10分钟 正常 CNAME www 默认 weixinbing.github.io – 10分钟 正常 然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存]]></content>
    </entry>

    
  
  
</search>
