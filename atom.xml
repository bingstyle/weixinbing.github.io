<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bingol&#39;s Blog</title>
  <subtitle>Do one thing at a time, and do well.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bingol.com/"/>
  <updated>2016-12-22T13:18:20.000Z</updated>
  <id>http://bingol.com/</id>
  
  <author>
    <name>weixb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS并发编程(Concurrent Programming)上</title>
    <link href="http://bingol.com/2016/12/22/iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(Concurrent%20Programming)%E4%B8%8A/"/>
    <id>http://bingol.com/2016/12/22/iOS并发编程(Concurrent Programming)上/</id>
    <published>2016-12-22T12:43:06.000Z</published>
    <updated>2016-12-22T13:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>进程(process):</p>
<ul>
<li>正在运行中的程序(可执行文件)称为进程</li>
<li>拥有独立的虚拟内存空间和系统资源，包括端口权限等</li>
<li>当一个进程的主线程退出时，这个进程就结束了</li>
</ul>
<p>线程(thread): </p>
<ul>
<li>线程是进程中一个独立的代码执行路径(控制单元)</li>
<li>一个进程中至少包含一条线程，即主线程</li>
<li>可以将耗时的执行路径(如：网络请求)放在其他线程中执行</li>
</ul>
<blockquote>
<p>在 iOS 中，线程的底层实现是基于 <code>POSIX threads API</code> 的，也就是我们常说的 pthreads</p>
</blockquote>
<a id="more"></a>
<p>任务(task):</p>
<ul>
<li>需要执行的工作，是一个抽象的概念</li>
<li>通俗的说，就是一段代码</li>
</ul>
<p>队列(queue):</p>
<ul>
<li>串行队列，队列中的任务只会顺序执行</li>
<li>并行队列，队列中的任务通常会并发执行</li>
</ul>
<blockquote>
<p>iOS 系统就是使用队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>
</blockquote>
<p>同步和异步:</p>
<ul>
<li>串行与并行针对的是队列，而同步与异步，针对的则是线程。</li>
<li>最大的区别在于，同步操作要阻塞当前线程，必须要等待同步操作中的任务执行完，返回以后，才能继续执行下一任务；而异步操作则是不用等待</li>
</ul>
<p>并发(concurrent)：</p>
<ul>
<li>同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。</li>
</ul>
<blockquote>
<p>调度原理</p>
<ul>
<li>多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将短暂的时间片(Timeslice)分配给每一个线程轮流使用CPU</li>
<li>由于CPU对每个时间片的处理速度非常快, 因此，用户看来好像这些任务在同时执行的</li>
<li>如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。</li>
</ul>
</blockquote>
<h2 id="多线程优势、弊端和误区"><a href="#多线程优势、弊端和误区" class="headerlink" title="多线程优势、弊端和误区"></a>多线程优势、弊端和误区</h2><p>优势:</p>
<ul>
<li>充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态</li>
<li>将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好</li>
<li>当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整</li>
</ul>
<p>弊端:</p>
<ul>
<li>新建线程会消耗内存空间和CPU时间，线程太多会降低系统的运行性能</li>
</ul>
<p>误区:</p>
<ul>
<li>多线程技术是为了并发执行多项任务，不会提高单个算法本身的执行效率</li>
</ul>
<h2 id="iOS的三种多线程技术"><a href="#iOS的三种多线程技术" class="headerlink" title="iOS的三种多线程技术"></a>iOS的三种多线程技术</h2><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread 是 Objective-C 对 pthread 的一个封装。</p>
<ul>
<li>使用NSThread对象建立一个线程非常方便</li>
<li>但是！要使用NSThread管理多个线程非常困难，不推荐使用</li>
<li>技巧！使用[NSThread currentThread]跟踪任务所在线程(包括GCD和Operation Queues)</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。</p>
<ul>
<li>是基于C语言的底层API</li>
<li>用Block定义任务，使用起来非常灵活便捷</li>
<li>提供了更多的控制能力以及操作队列中所不能使用的底层函数</li>
</ul>
<h3 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h3><p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。</p>
<ul>
<li>是使用GCD实现的一套Objective-C的API</li>
<li>是面向对象的多线程技术</li>
<li>提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</li>
</ul>
<p>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSOperationQueue</span> mainQueue] <span class="comment">//获取主队列</span></div><div class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init]; <span class="comment">//自定义队列</span></div></pre></td></tr></table></figure></p>
<p>主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。</p>
<h2 id="Grand-Central-Dispatch（GCD）"><a href="#Grand-Central-Dispatch（GCD）" class="headerlink" title="Grand Central Dispatch（GCD）"></a>Grand Central Dispatch（GCD）</h2><p>GCD的基本思想是就将操作放在队列中去执行</p>
<blockquote>
<p>操作使用Blocks定义<br>队列负责调度操作执行所在的线程以及具体的执行时间<br>队列的特点是先进先出(FIFO)的，新添加至队列的操作都会排在队尾</p>
</blockquote>
<p>提示:</p>
<ul>
<li>GCD的函数都是以dispatch开头的</li>
</ul>
<p>操作:</p>
<ul>
<li>dispatch_async 异步操作</li>
<li>dispatch_sync 同步操作</li>
</ul>
<p>注：</p>
<ul>
<li>队列不是线程？也不表示对应的CPU</li>
<li>队列就是负责调度的! 谁空闲，就把任务给谁！</li>
<li>多线程技术的目的，就是为了在一个CPU上实现快速切换！</li>
</ul>
<h3 id="GCD队列-dispatch-queue-t"><a href="#GCD队列-dispatch-queue-t" class="headerlink" title="GCD队列(dispatch_queue_t)"></a>GCD队列(dispatch_queue_t)</h3><p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>
<p><img src="http://oihqdel9t.bkt.clouddn.com/2016/12/Blog/gcd-queues.png" alt="GCD队列示意图"></p>
<blockquote>
<p>无论什么队列和什么任务，线程的创建和回收不需要程序员参与。<br>线程的创建回收工作是由队列负责的<br>“并发”编程，为了让程序员从负责的线程控制中解脱出来！只需要面对队列和任务！</p>
</blockquote>
<h4 id="GCD串行队列"><a href="#GCD串行队列" class="headerlink" title="GCD串行队列"></a>GCD串行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.s"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//异步操作会新建线程, 任务顺序执行(非常有用)</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="GCD并行队列"><a href="#GCD并行队列" class="headerlink" title="GCD并行队列"></a>GCD并行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.c"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//异步操作会新建多个线程, 任务无序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="GCD全局队列"><a href="#GCD全局队列" class="headerlink" title="GCD全局队列"></a>GCD全局队列</h4><p>全局队列与并行队列的区别:</p>
<ul>
<li>不需要创建，直接GET就能用</li>
<li>两个队列的执行效果相同</li>
<li>全局队列没有名称，调试时，无法确认准确队列</li>
</ul>
<blockquote>
<p><code>强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。</code><br>如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，造成<code>优先级反转</code>，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//异步操作会新建多个线程, 任务无序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="GCD主队列"><a href="#GCD主队列" class="headerlink" title="GCD主队列"></a>GCD主队列</h4><p>在iOS开发中，所有UI的更新工作，都必须在主线程上执行！<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</div><div class="line"><span class="comment">//同步操作会造成死锁,永远不会执行</span></div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"come here baby!"</span>);</div><div class="line">    &#125;);</div><div class="line"><span class="comment">// 异步操作，在主线程上运行，同时是保持队形的</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ - %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="GCD不同队列种嵌套dispatch-sync的结果"><a href="#GCD不同队列种嵌套dispatch-sync的结果" class="headerlink" title="GCD不同队列种嵌套dispatch_sync的结果"></a>GCD不同队列种嵌套dispatch_sync的结果</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局队列，都在主线程上执行，不会死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">// 并行队列，都在主线程上执行，不会死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.c"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">// 串行队列，会死锁，但是会执行嵌套同步操作之前的代码</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.s"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 直接死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>dispatch_sync的应用场景:</p>
<ul>
<li>阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录</li>
<li>确保块代码之外的局部变量确实被修改</li>
</ul>
<h3 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h3><p>这里有篇博客已经介绍得非常详细了,图文并茂, 浅显易懂<br><a href="http://www.saitjr.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">某妹纸博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;p&gt;进程(process):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正在运行中的程序(可执行文件)称为进程&lt;/li&gt;
&lt;li&gt;拥有独立的虚拟内存空间和系统资源，包括端口权限等&lt;/li&gt;
&lt;li&gt;当一个进程的主线程退出时，这个进程就结束了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程(thread): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程是进程中一个独立的代码执行路径(控制单元)&lt;/li&gt;
&lt;li&gt;一个进程中至少包含一条线程，即主线程&lt;/li&gt;
&lt;li&gt;可以将耗时的执行路径(如：网络请求)放在其他线程中执行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在 iOS 中，线程的底层实现是基于 &lt;code&gt;POSIX threads API&lt;/code&gt; 的，也就是我们常说的 pthreads&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bingol.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://bingol.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="http://bingol.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>发布框架到cocoapods</title>
    <link href="http://bingol.com/2016/12/20/%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B%E5%88%B0cocoapods/"/>
    <id>http://bingol.com/2016/12/20/发布工程到cocoapods/</id>
    <published>2016-12-20T02:02:34.000Z</published>
    <updated>2016-12-20T17:00:41.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在github建立仓库-并clone到本地"><a href="#在github建立仓库-并clone到本地" class="headerlink" title="在github建立仓库,并clone到本地"></a>在github建立仓库,并clone到本地</h3><p>github不是唯一的平台,其他平台都可以,前提是项目是开源的.</p>
<h3 id="创建-podspec文件"><a href="#创建-podspec文件" class="headerlink" title="创建.podspec文件"></a>创建.podspec文件</h3><p>打开终端,进入仓库,执行如下命令:</p>
<blockquote>
<p>pod spec create XXX</p>
</blockquote>
<h3 id="编辑-podspec文件"><a href="#编辑-podspec文件" class="headerlink" title="编辑.podspec文件"></a>编辑.podspec文件</h3><p>使用vim或Xcode打开.podspec文件,编辑如下:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|</div><div class="line">s.name = <span class="string">"XXX"</span></div><div class="line">s.<span class="keyword">version</span> = <span class="string">"1.0.3"</span></div><div class="line">s.ios.deployment_target = <span class="string">'8.0'</span></div><div class="line">s.summary = <span class="string">"some utilities"</span></div><div class="line">s.homepage = <span class="string">"https://github.com/weixinbing/XXX"</span></div><div class="line">s.license = &#123; :<span class="built_in">type</span> =&gt; <span class="string">"MIT"</span>, :<span class="keyword">file</span> =&gt; <span class="string">"LICENSE"</span> &#125;</div><div class="line">s.author = &#123; <span class="string">"weixb"</span> =&gt; <span class="string">"183292352@qq.com"</span> &#125;</div><div class="line">s.social_media_url = <span class="string">"http://weibo.com/u/5348162268"</span></div><div class="line">s.<span class="keyword">source</span> = &#123; :git =&gt; <span class="string">"https://github.com/weixinbing/XXX.git"</span>, :<span class="keyword">tag</span> =&gt; s.<span class="keyword">version</span> &#125;</div><div class="line">s.source_files = <span class="string">"XXX"</span></div><div class="line">s.requires_arc = true</div><div class="line">s.dependency <span class="string">"YTKNetwork"</span>, <span class="string">"~&gt; 2.0.3"</span></div><div class="line">s.dependency <span class="string">'Bugly'</span>, <span class="string">'~&gt; 2.4.2'</span></div><div class="line">end</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<blockquote>
<p>s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错<br>s.version：版本号<br>s.ios.deployment_target:支持的pod最低版本<br>s.summary: 简介<br>s.homepage:项目主页地址<br>s.license:许可证<br>s.author:作者<br>s.social_media_url:社交网址<br>s.source:项目的地址<br>s.source_files:需要包含的源文件<br>s.resources: 资源文件<br>s.requires_arc: 是否支持ARC<br>s.dependency：依赖库(可以多写)</p>
</blockquote>
<p>source_files:写法及含义:</p>
<blockquote>
<p>“”XXX”和“XXX/<em>” 表示匹配所有文件(不包含文件夹)<br>“XXX/</em>.{h,m}” 表示匹配所有以.h和.m结尾的文件(不包含文件夹)<br>“XXX/**” 表示匹配所有子目录(不包含文件夹)</p>
</blockquote>
<h3 id="验证本地仓库-podspec文件"><a href="#验证本地仓库-podspec文件" class="headerlink" title="验证本地仓库.podspec文件"></a>验证本地仓库.podspec文件</h3><blockquote>
<p>pod lib lint XXX.podspec</p>
</blockquote>
<h3 id="上传本地仓库到Git"><a href="#上传本地仓库到Git" class="headerlink" title="上传本地仓库到Git"></a>上传本地仓库到Git</h3><h3 id="给仓库打上tag"><a href="#给仓库打上tag" class="headerlink" title="给仓库打上tag"></a>给仓库打上tag</h3><blockquote>
<p>git tag ‘1.0.0’ //第一步<br>git push origin –tags //推送到远程仓库</p>
</blockquote>
<h3 id="验证远程仓库-podspec文件"><a href="#验证远程仓库-podspec文件" class="headerlink" title="验证远程仓库.podspec文件"></a>验证远程仓库.podspec文件</h3><blockquote>
<p>pod spec lint XXX.podspec</p>
</blockquote>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>发布前先验证是否已注册trunk：</p>
<blockquote>
<p>pod trunk me</p>
</blockquote>
<p>没有注册则使用命令：</p>
<blockquote>
<p>pod trunk register Email “Name” –verbose<br>注册完成之后会给你的邮箱发个邮件,进入邮箱邮件里面有个链接,需要点击确认一下</p>
</blockquote>
<p>已注册则执行发布命令：</p>
<blockquote>
<p>pod trunk push XXX.podspec</p>
</blockquote>
<p>发布成功就可以使用pod导入你的框架了。</p>
<h3 id="错误搜集"><a href="#错误搜集" class="headerlink" title="错误搜集"></a>错误搜集</h3><p>遇到错误CocoaPods was not able to update the <code>master</code> repo. If this is an unexpected issue and persists you can inspect it running <code>pod repo update --verbose</code><br>执行命令<code>pod repo update</code>即可</p>
<p>发布成功,执行<code>pod search XXX</code>搜索</p>
<p>遇到错误Unable to find a pod with name, author, summary, or descriptionmatching “XXX”的解决方法:</p>
<blockquote>
<p>方法1:使用终端命令<br><code>rm ~/Library/Caches/CocoaPods/search_index.json</code>  删除cocoapods本地缓存,再使用<code>pod search XXX</code>搜索.<br>方法2:使用终端命令<code>pod setup</code> 更新cocoapods的repo,再重复方法1.</p>
</blockquote>
<p>依赖错误, 可以使用 –use-libraries 来让验证通过.<br>警告错误, 可以使用 –allow-warnings 来让验证通过.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在github建立仓库-并clone到本地&quot;&gt;&lt;a href=&quot;#在github建立仓库-并clone到本地&quot; class=&quot;headerlink&quot; title=&quot;在github建立仓库,并clone到本地&quot;&gt;&lt;/a&gt;在github建立仓库,并clone到本地&lt;/h3&gt;&lt;p&gt;github不是唯一的平台,其他平台都可以,前提是项目是开源的.&lt;/p&gt;
&lt;h3 id=&quot;创建-podspec文件&quot;&gt;&lt;a href=&quot;#创建-podspec文件&quot; class=&quot;headerlink&quot; title=&quot;创建.podspec文件&quot;&gt;&lt;/a&gt;创建.podspec文件&lt;/h3&gt;&lt;p&gt;打开终端,进入仓库,执行如下命令:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pod spec create XXX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;编辑-podspec文件&quot;&gt;&lt;a href=&quot;#编辑-podspec文件&quot; class=&quot;headerlink&quot; title=&quot;编辑.podspec文件&quot;&gt;&lt;/a&gt;编辑.podspec文件&lt;/h3&gt;&lt;p&gt;使用vim或Xcode打开.podspec文件,编辑如下:&lt;br&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Pod::Spec.&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |s|&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.name = &lt;span class=&quot;string&quot;&gt;&quot;XXX&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.&lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;1.0.3&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.ios.deployment_target = &lt;span class=&quot;string&quot;&gt;&#39;8.0&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.summary = &lt;span class=&quot;string&quot;&gt;&quot;some utilities&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.homepage = &lt;span class=&quot;string&quot;&gt;&quot;https://github.com/weixinbing/XXX&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.license = &amp;#123; :&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;MIT&quot;&lt;/span&gt;, :&lt;span class=&quot;keyword&quot;&gt;file&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;LICENSE&quot;&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.author = &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;weixb&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;183292352@qq.com&quot;&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.social_media_url = &lt;span class=&quot;string&quot;&gt;&quot;http://weibo.com/u/5348162268&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.&lt;span class=&quot;keyword&quot;&gt;source&lt;/span&gt; = &amp;#123; :git =&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;https://github.com/weixinbing/XXX.git&quot;&lt;/span&gt;, :&lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; =&amp;gt; s.&lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.source_files = &lt;span class=&quot;string&quot;&gt;&quot;XXX&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.requires_arc = true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.dependency &lt;span class=&quot;string&quot;&gt;&quot;YTKNetwork&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;~&amp;gt; 2.0.3&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s.dependency &lt;span class=&quot;string&quot;&gt;&#39;Bugly&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;~&amp;gt; 2.4.2&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;end&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="cocoapods" scheme="http://bingol.com/categories/cocoapods/"/>
    
    
      <category term="cocoapods" scheme="http://bingol.com/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>YYModel,MJExtension,JSONModel对比</title>
    <link href="http://bingol.com/2016/12/20/YYModel,MJExtension,JSONModel%E5%AF%B9%E6%AF%94/"/>
    <id>http://bingol.com/2016/12/20/YYModel,MJExtension,JSONModel对比/</id>
    <published>2016-12-19T16:02:25.000Z</published>
    <updated>2016-12-19T16:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h3><blockquote>
<p>JSONModel要求所有模型类必须继承自JSONModel基类<br>YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性</p>
</blockquote>
<h3 id="量级上"><a href="#量级上" class="headerlink" title="量级上"></a>量级上</h3><blockquote>
<p>YYModel和MJExtension都是超轻量级框架<br>YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高.</p>
</blockquote>
<a id="more"></a>
<h3 id="字典和模型之间互相转换"><a href="#字典和模型之间互相转换" class="headerlink" title="字典和模型之间互相转换"></a>字典和模型之间互相转换</h3><blockquote>
<p>MJExtension支持:<br>Plist –&gt; Model Array<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">模型数组 = [模型类名 objectArrayWithFilename:<span class="string">@"文件名.plist"</span>];</div></pre></td></tr></table></figure></p>
<p>JSON Array –&gt; Model Array<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *modelArray = [模型类名 objectArrayWithKeyValuesArray:字段数组];</div></pre></td></tr></table></figure></p>
<p>JSONString –&gt; Model Array<br>Model Array –&gt; JSON Array<br>YYModel没有看到对字典数组和模型数组相互转换的支持</p>
</blockquote>
<h3 id="容器类属性"><a href="#容器类属性" class="headerlink" title="容器类属性"></a>容器类属性</h3><blockquote>
<p>YYModel需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"arrayName"</span> : [模型类名 <span class="keyword">class</span>]&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MJExtension需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"arrayName"</span> : [模型类名 <span class="keyword">class</span>]&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p> <code>MJExtension可以配合ESJsonFormat模型插件使用,插件自动实现容器方法.YYModel也可以配合ESJsonFormat模型插件使用,需要修改容器实现的方法名.</code></p>
<blockquote>
<p>JSONModel是最简单的,只需要参照以下写法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> &lt;ProductModel&gt; *products;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="归档和解档"><a href="#归档和解档" class="headerlink" title="归档和解档"></a>归档和解档</h3><blockquote>
<p>三者性能相当<br>MJExtension只需要一行代码调用写好的宏MJExtensionCodingImplementation就可以实现<br>YYModel需要遵守NSCoding协议,并重写下面方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123; [<span class="keyword">self</span> yy_modelEncodeWithCoder:aCoder]; &#125;</div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123; <span class="keyword">self</span> = [<span class="keyword">super</span> init]; <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelInitWithCoder:aDecoder]; &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><blockquote>
<p>MJExtension只需要在@implementation 和 @end之间写上宏MJLogAllIvrs,就能解决调试时，打印模型，只打印出内存地址的问题<br>YYModel需要重写description方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)description &#123; <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelDescription]; &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="模型中的属性名和字典中的key不相同-或者需要多级映射"><a href="#模型中的属性名和字典中的key不相同-或者需要多级映射" class="headerlink" title="模型中的属性名和字典中的key不相同(或者需要多级映射)"></a>模型中的属性名和字典中的key不相同(或者需要多级映射)</h3><blockquote>
<p>YYModel需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"name"</span> : <span class="string">@"n"</span>,</div><div class="line">             <span class="string">@"page"</span> : <span class="string">@"p"</span>,</div><div class="line">             <span class="string">@"desc"</span> : <span class="string">@"ext.desc"</span>,</div><div class="line">             <span class="string">@"bookID"</span> : @[<span class="string">@"id"</span>,<span class="string">@"ID"</span>,<span class="string">@"book_id"</span>]</div><div class="line">             &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MJExtension需要在转换代码之前实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[Student mj_setupReplacedKeyFromPropertyName:^<span class="built_in">NSDictionary</span> *&#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">               <span class="string">@"ID"</span> : <span class="string">@"id"</span>,</div><div class="line">               <span class="string">@"desc"</span> : <span class="string">@"desciption"</span>,</div><div class="line">               <span class="string">@"oldName"</span> : <span class="string">@"name.oldName"</span>,</div><div class="line">               <span class="string">@"nowName"</span> : <span class="string">@"name.newName"</span>,</div><div class="line">               <span class="string">@"nameChangedTime"</span> : <span class="string">@"name.info[1].nameChangedTime"</span>,</div><div class="line">               <span class="string">@"bag"</span> : <span class="string">@"other.bag"</span></div><div class="line">           &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;使用区别&quot;&gt;&lt;a href=&quot;#使用区别&quot; class=&quot;headerlink&quot; title=&quot;使用区别&quot;&gt;&lt;/a&gt;使用区别&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JSONModel要求所有模型类必须继承自JSONModel基类&lt;br&gt;YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;量级上&quot;&gt;&lt;a href=&quot;#量级上&quot; class=&quot;headerlink&quot; title=&quot;量级上&quot;&gt;&lt;/a&gt;量级上&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;YYModel和MJExtension都是超轻量级框架&lt;br&gt;YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bingol.com/categories/iOS/"/>
    
    
      <category term="JSON" scheme="http://bingol.com/tags/JSON/"/>
    
      <category term="MODEL" scheme="http://bingol.com/tags/MODEL/"/>
    
      <category term="模型框架" scheme="http://bingol.com/tags/%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>OC预处理命令</title>
    <link href="http://bingol.com/2016/12/19/OC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://bingol.com/2016/12/19/OC预处理命令/</id>
    <published>2016-12-18T16:42:26.000Z</published>
    <updated>2016-12-19T16:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。<br>指令用途：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#空指令，无任何效果</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>包含一个源代码文件</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>定义宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span>取消已定义的宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 如果给定条件为真，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>如果宏已经定义，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>如果宏没有定义，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span>如果前面的#<span class="meta-keyword">if</span>给定条件不为真，当前条件为真，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>结束一个#<span class="meta-keyword">if</span>……#<span class="meta-keyword">else</span>条件编译块</span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span>停止编译并显示错误信息</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>#include</code>预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。</p>
<p><code>#运算符</code><br>出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#definePASTE(n)<span class="meta-string">"adhfkj"</span>#n</span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%s "</span>,PASTE(<span class="number">15</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。</p>
<p><code>##运算符</code><br>用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#defineNUM(a,b,c)a##b##c</span></div><div class="line"><span class="meta">#defineSTR(a,b,c)a##b##c</span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%d "</span>,NUM(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</div><div class="line">printf(<span class="string">"%s "</span>,STR(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>));</div><div class="line">&#125;</div><div class="line">最后程序的输出为:</div><div class="line"><span class="number">123</span></div><div class="line">aabbcc1</div></pre></td></tr></table></figure></p>
<h2 id="条件编译指令"><a href="#条件编译指令" class="headerlink" title="条件编译指令"></a>条件编译指令</h2><p>条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。</p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="#if指令"></a><code>#if指令</code></h3><p>检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。</p>
<h3 id="endif指令"><a href="#endif指令" class="headerlink" title="#endif指令"></a><code>#endif指令</code></h3><p>用于终止#if预处理指令。</p>
<h3 id="ifdef和-ifndef"><a href="#ifdef和-ifndef" class="headerlink" title="#ifdef和#ifndef"></a><code>#ifdef和#ifndef</code></h3><p>用于#define命令定义过则进行编译</p>
<h3 id="else指令"><a href="#else指令" class="headerlink" title="#else指令"></a><code>#else指令</code></h3><p>用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。</p>
<h3 id="elif指令"><a href="#elif指令" class="headerlink" title="#elif指令"></a><code>#elif指令</code></h3><p>综合了#else和#if指令的作用。</p>
<h3 id="其他一些标准指令"><a href="#其他一些标准指令" class="headerlink" title="其他一些标准指令"></a><code>其他一些标准指令</code></h3><blockquote>
<p><code>#error</code>指令将使编译器显示一条错误信息，然后停止编译。<br><code>#line</code>指令可以改变编译器用来指出警告和错误信息的文件号和行号。<br><code>#pragma</code>指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</p>
</blockquote>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。</p>
<h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdef _XXXX</span></div><div class="line">...程序段<span class="number">1.</span>..</div><div class="line"><span class="meta">#else</span></div><div class="line">...程序段<span class="number">2.</span>..</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。</p>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef _XXXX </span></div><div class="line">...程序段<span class="number">1.</span>.. </div><div class="line"><span class="meta">#else </span></div><div class="line">...程序段<span class="number">2.</span>.. </div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。</p>
<h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if 常量 </span></div><div class="line">...程序段<span class="number">1.</span>..</div><div class="line"><span class="meta">#else</span></div><div class="line">...程序段<span class="number">2.</span>..</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。<br>我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。&lt;br&gt;指令用途：&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#空指令，无任何效果&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;包含一个源代码文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;定义宏&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;undef&lt;/span&gt;取消已定义的宏&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; 如果给定条件为真，则编译下面代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifdef&lt;/span&gt;如果宏已经定义，则编译下面代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;ifndef&lt;/span&gt;如果宏没有定义，则编译下面代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt;如果前面的#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt;给定条件不为真，当前条件为真，则编译下面代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;结束一个#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt;……#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;条件编译块&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt;停止编译并显示错误信息&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://bingol.com/categories/Objective-C/"/>
    
    
      <category term="预处理" scheme="http://bingol.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 结合 Github 搭建的博客</title>
    <link href="http://bingol.com/2016/12/18/Hexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://bingol.com/2016/12/18/Hexo 结合 Github 搭建的博客/</id>
    <published>2016-12-18T11:00:27.000Z</published>
    <updated>2016-12-22T13:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul>
<li>安装Node.js <a href="https://nodejs.org/en/" target="_blank" rel="external">官网https://nodejs.org/en/</a></li>
<li>安装Git（Xcode自带有Git）</li>
<li>注册GitHub账号（用于博客的远程仓库）</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>打开终端，执行命令：</p>
<pre><code>npm install hexo-cli -g
</code></pre><p>如果报错，加上sudo。<br>hexo常用命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo g   <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></div><div class="line">hexo s   <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></div><div class="line">hexo d   <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github上</span></div><div class="line">hexo n   <span class="comment">#完整命令为hexo new,用于新建一篇文章</span></div><div class="line">hexo clean   <span class="comment">#清除生成的文件</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="初始化博客文件夹"><a href="#初始化博客文件夹" class="headerlink" title="初始化博客文件夹"></a>初始化博客文件夹</h2><pre><code>hexo init [文件夹名字] 
cd [文件夹名字] 
npm install
</code></pre><p>成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> ：</p>
<pre><code>hexo s
</code></pre><p>如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试：</p>
<pre><code>npm install hexo-server --save
</code></pre><h2 id="编辑hexo的配置文件"><a href="#编辑hexo的配置文件" class="headerlink" title="编辑hexo的配置文件"></a>编辑hexo的配置文件</h2><p>不要被文件内容吓到了，只需要修改以下地方：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line"><span class="symbol">title:</span> xxx</div><div class="line"><span class="symbol">subtitle:</span> xxx</div><div class="line"><span class="symbol">description:</span> xxx</div><div class="line"><span class="symbol">author:</span> xxx</div><div class="line"><span class="symbol">language:</span> zh-Hans</div><div class="line"><span class="symbol">timezone:</span> Asia/Shanghai</div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line"><span class="symbol">deploy:</span></div><div class="line">  <span class="symbol">type:</span> git</div><div class="line">  <span class="symbol">repo:</span> github仓库的克隆地址</div><div class="line">  <span class="symbol">branch:</span> master</div></pre></td></tr></table></figure>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通常情况下是先生成网站，然后部署。可以将两个步骤放到一起：</p>
<pre><code>hexo d -g
</code></pre><p>现在你就可以打开网站看到效果了。<br>如果提示：</p>
<pre><code>ERROR Deployer not found:git
</code></pre><p>需要要安装hexo-deployer-git：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>完成后执行部署命令hexo d -g。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>通过以下命令新建文章：</p>
<pre><code>hexo new “文章名字&quot;
</code></pre><p>然后用编辑器打开 source_posts 里的md文件编辑。<br>更新文章：</p>
<pre><code>hexo d -g
</code></pre><p>这样就可以把你的新文章传上去啦。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="external">NexT 官方WiKi</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT 官方网站</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;配置环境&quot;&gt;&lt;a href=&quot;#配置环境&quot; class=&quot;headerlink&quot; title=&quot;配置环境&quot;&gt;&lt;/a&gt;配置环境&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装Node.js &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网https://nodejs.org/en/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装Git（Xcode自带有Git）&lt;/li&gt;
&lt;li&gt;注册GitHub账号（用于博客的远程仓库）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装Hexo&quot;&gt;&lt;a href=&quot;#安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo&quot;&gt;&lt;/a&gt;安装Hexo&lt;/h2&gt;&lt;p&gt;打开终端，执行命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-cli -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果报错，加上sudo。&lt;br&gt;hexo常用命令：&lt;br&gt;&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;hexo g   &lt;span class=&quot;comment&quot;&gt;#完整命令为hexo generate,用于生成静态文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hexo s   &lt;span class=&quot;comment&quot;&gt;#完整命令为hexo server,用于启动服务器，主要用来本地预览&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hexo d   &lt;span class=&quot;comment&quot;&gt;#完整命令为hexo deploy,用于将本地文件发布到github上&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hexo n   &lt;span class=&quot;comment&quot;&gt;#完整命令为hexo new,用于新建一篇文章&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;hexo clean   &lt;span class=&quot;comment&quot;&gt;#清除生成的文件&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://bingol.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://bingol.com/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://bingol.com/tags/NexT/"/>
    
  </entry>
  
</feed>
