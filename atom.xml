<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bingol&#39;s Blog</title>
  <subtitle>Do one thing at a time, and do well.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.weixinbing.com/"/>
  <updated>2017-07-16T14:53:04.000Z</updated>
  <id>http://www.weixinbing.com/</id>
  
  <author>
    <name>weixb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中的关键字const／static／extern</title>
    <link href="http://www.weixinbing.com/2017/07/16/iOS%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97const%EF%BC%8Fstatic%EF%BC%8Fextern/"/>
    <id>http://www.weixinbing.com/2017/07/16/iOS中的关键字const／static／extern/</id>
    <published>2017-07-16T14:36:36.000Z</published>
    <updated>2017-07-16T14:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="const"><a href="#const" class="headerlink" title="const:"></a>const:</h4><p>const只修饰其右边的变量，被修饰的变量是只读的；<br>const常量不能被修改，不能用来定义数组的长度，也不能放在case关键字后面。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p</div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p	</div><div class="line"><span class="comment">// *p只读, p变量(这2种没有区别)</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p	</div><div class="line"><span class="comment">// *p变量, p只读</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p	  </div><div class="line"><span class="comment">// *p只读, p只读</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p   </div><div class="line"><span class="comment">// *p只读, p只读</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<blockquote>
<p>const常量误区：<br>   <code>const int n = 5; int a[n];</code><br>   上述代码中变量n被修饰为只读变量，可惜再怎么修饰也不是“常量”，而数组定义时长度必须是“常量”，因此报错。</p>
<p>const int MAX_LENGTH = 100; //这不是“常量”，而是一个只读变量。</p>
</blockquote>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><h5 id="1-修饰局部变量"><a href="#1-修饰局部变量" class="headerlink" title="1. 修饰局部变量"></a>1. 修饰局部变量</h5><p>保证局部变量永远只初始化一次，在程序的运行过程中永远只有一份内存， 生命周期类似全局变量了，但是作用域不变。</p>
<h5 id="2-修饰全局变量"><a href="#2-修饰全局变量" class="headerlink" title="2. 修饰全局变量"></a>2. 修饰全局变量</h5><p>使全局变量的作用域仅限于当前文件内部，不能通过extern来引用</p>
<h5 id="3-修饰函数"><a href="#3-修饰函数" class="headerlink" title="3. 修饰函数"></a>3. 修饰函数</h5><p>被修饰的函数被称为静态函数，使得外部文件无法访问这个函数，OC语言中很少使用。</p>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>它的作用是声明外部全局变量</p>
<p>苹果推荐extern声明全局变量（不建议使用define），优势是保持常量绝对不会被修改，并且还带有初始化的类型信息。<br>通常在.h中声明，在.m中实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .h声明</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> NAME;</div><div class="line"></div><div class="line"><span class="comment">// .m实现</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> NAME = <span class="string">@"XXX"</span>;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>const是用来定义一个常量。而static在C语言中（OC中延用）表明此变量只在该变量的输出文件中可用(.m文件)，如果你不加“static”符号，那么编译器就会对该变量创建一个“外部符号”，后果是什么呢？</p>
<p>你可以尝试在不同文件中加入以下代码：<br><code>NSString  * const kUserName = @&quot;StrongX&quot;;</code><br>可能尽管文件之间并没有相互引用，不存在属性名重复的问题（因为这并不是一个属性，这是一个外部符号）,但是编译器还是报错了:<br><code>duplicate symbol XXX in: ....
clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></p>
<p>它会告诉你在两个目标文件(.o文件是.m文件编译后的输出文件)有一个重复的符号。(OC中没有类似C++中的名字空间的概念)<br>所以当你在你自己的.m文件中需要声明一个只有你自己可见的局部变量(k开头)的变量的时候<br><code>一定要同时使用“static”和“const”两个关键字。</code></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;const&quot;&gt;&lt;a href=&quot;#const&quot; class=&quot;headerlink&quot; title=&quot;const:&quot;&gt;&lt;/a&gt;const:&lt;/h4&gt;&lt;p&gt;const只修饰其右边的变量，被修饰的变量是只读的；&lt;br&gt;const常量不能被修改，不能用来定义数组的长度，也不能放在case关键字后面。&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; *p	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// *p只读, p变量(这2种没有区别)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// *p变量, p只读&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p	  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// *p只读, p只读&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; p   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// *p只读, p只读&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.weixinbing.com/categories/iOS/"/>
    
    
      <category term="关键字" scheme="http://www.weixinbing.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>View层代码结构规范</title>
    <link href="http://www.weixinbing.com/2017/07/10/View%E5%B1%82%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83/"/>
    <id>http://www.weixinbing.com/2017/07/10/View层代码结构规范/</id>
    <published>2017-07-10T00:05:39.000Z</published>
    <updated>2017-07-10T00:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>针对View层的架构设计，还是要做好三点：</p>
<ul>
<li>代码规范</li>
<li>架构模式</li>
<li>工具集</li>
</ul>
<a id="more"></a>
<blockquote>
<p>View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。各自实现或者使用CocoaPods里现成的都不是很难。</p>
</blockquote>
<h4 id="关于View的代码规范"><a href="#关于View的代码规范" class="headerlink" title="关于View的代码规范"></a>关于View的代码规范</h4><p>目的:</p>
<ol>
<li>提高业务方View层的可读性可维护性</li>
<li>防止业务代码对架构产生腐蚀</li>
<li>保持架构发展的方向不轻易被不合理的意见所左右</li>
<li>确保传承</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - Init</span></div><div class="line"><span class="comment">/* init, dealloc */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Life cycle</span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Delegate</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Event response</span></div><div class="line"><span class="comment">/* 所有button、gestureRecognizer的响应事件都放在这个区域里面 */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Private methods</span></div><div class="line"><span class="comment">/* 关于private methods，正常情况下ViewController里面不应该写,</span></div><div class="line"> 要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Getters and setters</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在viewDidload里面只做addSubview的事情<br>在viewDidAppear里面做Notification的监听之类的事情<br>在updateViewConstraints里面做add constraints的事情<br>属性的初始化，则交给getter去做<br>每一个delegate都把对应的protocol名字带上<br>所有button、gestureRecognizer的响应事件都放在Event response这个区域里面</p>
</blockquote>
<h4 id="关于View的布局"><a href="#关于View的布局" class="headerlink" title="关于View的布局"></a>关于View的布局</h4><p><code>苹果文档中指出，updateViewConstraints是用来做add constraints的地方。</code><br>建议使用Masonry，代码的可读性就能好很多。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;针对View层的架构设计，还是要做好三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码规范&lt;/li&gt;
&lt;li&gt;架构模式&lt;/li&gt;
&lt;li&gt;工具集&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.weixinbing.com/categories/iOS/"/>
    
    
      <category term="代码规范" scheme="http://www.weixinbing.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Mac工具箱</title>
    <link href="http://www.weixinbing.com/2017/05/13/Mac%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <id>http://www.weixinbing.com/2017/05/13/Mac工具箱/</id>
    <published>2017-05-13T14:53:43.000Z</published>
    <updated>2017-05-13T15:07:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.alfredapp.com" target="_blank" rel="external">Alfred</a><br>Alfred是我见过的最能将Mac的效率使用到极致的工具了。小到翻译一个英文单词，搜索一个文件，大到用一个命令完成本地开发环境的部署启动，都可以通过Alfred来完成。你可以将大部分的重复劳动让Alfred来帮助你完成。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/Alfred.jpeg" alt="enter image description here"><br><a id="more"></a><br><a href="https://www.sketchapp.com" target="_blank" rel="external">Sketch 3</a><br>一款UI设计工具。Sketch只有几十M，相较于Photoshop,它小巧得多，更重要的是它是专为UI设计而生的，我不必关注那些与我做UI设计毫无关系的图片处理功能，从而降低了工作环境中的噪音。另外，通过强大的插件功能，我能根据需要进行安装使用，这大大提高了我的工作效率。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/sketch3.png" alt="enter image description here"></p>
<p><a href="https://www.paintcodeapp.com" target="_blank" rel="external">PaintCode</a><br>你可以使用PaintCode方便地进行图形设计，你也可以将SVG或PSD文件导入到PaintCode中，然后它就能帮助你将你的设计转换成Objective-C,Swift或C#代码。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/PaintCode.png" alt="enter image description here"></p>
<p><a href="http://sipapp.io" target="_blank" rel="external">Sip for Mac and iPhone</a><br>Sip是一个非常出色的iOS app，它能帮助你从照片中创建色板。并且你可以在你的Mac或手机上随时随地使用它捕捉那些美丽的色彩。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/sip.png" alt="enter image description here"></p>
<p><a href="http://www.sublimetext.com" target="_blank" rel="external">Sublime Text 3</a><br>这是我开发前端代码时 使用的IDE。我非常喜欢它的那些使代码异常清晰的主题，以及功能丰富的插件。有了它开发HTML、CSS、JavaScript变成了一件非常愉悦的事情。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/Sublime.png" alt="enter image description here"></p>
<p><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a><br>Dash对开发人员非常有帮助，我能够在离线的状态下查看如Angular，Swift，CSS等的技术文档。这使得我在网络条件不好的情况下也能工作，并且极大提升我的工作效率。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/dash.png" alt="enter image description here"></p>
<p><a href="https://www.cheatsheetapp.com/CheatSheet/" target="_blank" rel="external">CCheatSheet</a><br>CheatSheet是我非常喜欢的一个小工具，任何流行的软件都会有一堆的快捷键设置，通过这个工具，你只需要长按?键，这个软件的所有快捷键就会显示在你的面前，你完全不用逐一去背，只要反复查看几次，你自然就能熟练运用那些快捷键了。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/CheatSheet.png" alt="enter image description here"></p>
<p><a href="https://flexibits.com/fantastical" target="_blank" rel="external">Fantastical</a><br>我使用Fantastical来快速地记录我的todo事项，并设定提醒。我只记录那些比较重要的事项，而不会每天把所有很细小的行动项都记录下来，因为那样反而会让我有一种压迫感而分心。我更喜欢在自然舒缓的环境中工作。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/Fantastical.png" alt="enter image description here"></p>
<p><a href="http://www.cockos.com/licecap/" target="_blank" rel="external">LiceCap</a><br>这使一个很小的免费软件，你可以在屏幕上设定一个区域，然后就可以用LiceCap来快速地录制GIF动画了。直接、高效是我对它的评价。<br><img src="http://oihqdel9t.bkt.clouddn.com/md/MacTool/LiceCap.png" alt="enter image description here"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.alfredapp.com&quot;&gt;Alfred&lt;/a&gt;&lt;br&gt;Alfred是我见过的最能将Mac的效率使用到极致的工具了。小到翻译一个英文单词，搜索一个文件，大到用一个命令完成本地开发环境的部署启动，都可以通过Alfred来完成。你可以将大部分的重复劳动让Alfred来帮助你完成。&lt;br&gt;&lt;img src=&quot;http://oihqdel9t.bkt.clouddn.com/md/MacTool/Alfred.jpeg&quot; alt=&quot;enter image description here&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="MAC" scheme="http://www.weixinbing.com/categories/MAC/"/>
    
    
      <category term="工具" scheme="http://www.weixinbing.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Git命令大全</title>
    <link href="http://www.weixinbing.com/2017/01/19/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93/"/>
    <id>http://www.weixinbing.com/2017/01/19/创建仓库/</id>
    <published>2017-01-19T14:56:20.000Z</published>
    <updated>2017-01-19T14:59:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git Command<br><a id="more"></a></p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ul>
<li>git init  创建git仓库</li>
</ul>
<h3 id="添加提交"><a href="#添加提交" class="headerlink" title="添加提交"></a>添加提交</h3><ul>
<li>git add <file> 添加(从工作区到暂存区,可多次使用添加多个文件)</file></li>
<li>git commit -m “description” 提交(从暂存区到本地仓库)</li>
</ul>
<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul>
<li>git status 查看仓库当前状态</li>
<li>git diff <file> 查看添加前修改的内容</file></li>
<li>git diff HEAD — <file> 查看工作区和版本库最新版本的区别</file></li>
<li>git log 查看提交日志</li>
<li>git log —pretty=oneline 查看提交日志(单行显示每一条日志)</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul>
<li>git reset —hard HEAD^ 回滚到上个版本</li>
<li>git reset —hard HEAD^^ 回滚到上上个版本</li>
<li>git reset —hard HEAD~n 回滚到上n个版本</li>
<li>git reset —hard <commit id=""> 回滚到指定提交id的版本</commit></li>
</ul>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul>
<li>rm <file> 删除工作区文件</file></li>
<li>git checkout — <file> 撤销(丢弃)工作区的修改(让工作区和HEAD保持一致)</file></li>
<li>git reset HEAD <file> 撤销暂存区的文件(个人理解为撤销git add命令)</file></li>
<li>git rm <file> 从版本库中删除文件(会同时删除工作区文件,个人理解为rm <file>命令 + git add <file>命令 )</file></file></file></li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>git remote add origin <ssh或https>关联远程仓库</ssh或https></li>
<li>git push -u origin master 第一次推送master分支的所有内容</li>
<li>git push origin master 推送master分支的所有内容(origin为远程库)</li>
<li>git pull —rebase origin master 拉取master分支的内容</li>
<li>git pull 拉取关联的远程分支内容</li>
<li>git branch —set-upstream branch-name origin/branch-name 设置本地分支和远程分支的链接关系<br><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong>分割线<strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></li>
<li>git clone <ssh或https> 克隆远程仓库</ssh或https></li>
</ul>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul>
<li>git branch dev 创建一个dev分支</li>
<li>git checkout dev 切换到dev分支</li>
<li>git checkout -b dev 创建一个dev分支并切换到dev分支</li>
<li>git checkout -b dev origin/dev 创建远程origin的dev分支到本地</li>
<li>git branch 查看分支(列出所有分支,当前分支前有*标记)</li>
<li>git merge dev 合并指定分支到当前分支</li>
<li>git merge —no-ff -m “desc” dev 合并dev分支到当前分支并禁用”fast forward”</li>
<li>git branch -d dev 删除dev分支</li>
<li>git branch -D dev 强行删除一个没有被合并过的dev分支<br><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong>分割线<strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></li>
<li>git log —graph 查看分支的合并情况</li>
<li>git log —graph —pretty=oneline  查看分支的合并情况(单行)</li>
<li>git log —graph —pretty=oneline —abbrev-commit 查看分支的合并情况(单行短id)</li>
</ul>
<h3 id="贮藏管理"><a href="#贮藏管理" class="headerlink" title="贮藏管理"></a>贮藏管理</h3><ul>
<li>git stash 贮藏当前工作区的修改(可多次stash)</li>
<li>git stash list 查看贮藏列表</li>
<li>git stash apply 恢复stash内容(不删除stash内容)</li>
<li>git stash drop 删除stash内容</li>
<li>git stash pop 恢复并删除stash内容</li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><ul>
<li>git tag <name> 给当前分支上最新的的commitId打上标签</name></li>
<li>git tag 查看所有标签(按字母排序,不按时间)</li>
<li>git tag <name> <commitid> 给对应的commitId打上标签</commitid></name></li>
<li>git show <name> 查看标签信息</name></li>
<li>git tag -a <name> -m “desc” <commitid> 创建带有说明的标签(-a指定标签名,-m指定说明文字)</commitid></name></li>
<li>git tag -s <name> -m “desc” <commitid> 用PGP签名标签</commitid></name></li>
<li>git tag -d <name> 删除标签</name></li>
<li>git push origin :refs/tags/<name> 删除远程标签(需要先删除本地标签)</name></li>
<li>git push origin <name> 推送标签到远程</name></li>
<li>git push origin —tags 推送所有标签到远程</li>
</ul>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><ul>
<li>git add -f <name> 强制添加被.gitignore忽略不能添加的文件</name></li>
<li>git check-ignore -v <name> 查看文件被忽略的原因</name></li>
</ul>
<h3 id="别名定义"><a href="#别名定义" class="headerlink" title="别名定义"></a>别名定义</h3><ul>
<li>git config —global alias.st status 配置查看仓库状态的别名</li>
<li>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git Command&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.weixinbing.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.weixinbing.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Xcode8新特性之Thread Sanitizer</title>
    <link href="http://www.weixinbing.com/2016/12/31/Xcode8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BThread%20Sanitizer/"/>
    <id>http://www.weixinbing.com/2016/12/31/Xcode8新特性之Thread Sanitizer/</id>
    <published>2016-12-30T16:00:00.000Z</published>
    <updated>2017-01-19T14:35:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程问题调试工具<br><a id="more"></a></p>
<h3 id="Thread-Sanitizer的使用"><a href="#Thread-Sanitizer的使用" class="headerlink" title="Thread Sanitizer的使用"></a>Thread Sanitizer的使用</h3><p>打开Xcode 8新增的多线程问题调试工具Thread Sanitizer<br><img src="http://oihqdel9t.bkt.clouddn.com/2012/12/Xcode%20Thread%20Sanitizer.png" alt="Xcode Thread Sanitizer"></p>
<p>运行下图中代码，检测data race<br><img src="http://oihqdel9t.bkt.clouddn.com/2012/12/count%20data%20race.png" alt="count data race"><br>很直观，Xcode直接提示你发生了data race的变量及其代码位置，同时还清晰的展示了函数当前的各线程调用栈，十分清晰，接下来你要做的就是增加同步操作，比如加锁，从而消除data race，再运行测试是否生效。</p>
<blockquote>
<p>最后计算的结果有很大概率小于20000，原因是count ++为非原子操作。这也是data race的场景，这种race没有crash也没有memory corruption，因此有些人把这种race称作benign race(良性的race)。不过上面提到的WWDC视频中，苹果的工程师说到：<br><code>There is No Such Thing as a “Benign” Race</code><br>意思是，只要发生data race，就没有良性一说了，因为虽然程序没有crash，但count最后的值还是出错了，这种 错误必然会导致逻辑上的错误，如果这个count值代表的是你银行卡余额，你应该会更加同意苹果工程师的观点。</p>
</blockquote>
<p>data race定义：</p>
<ul>
<li>当至少有两个线程同时访问同一个变量，而且至少其中有一个是写操作时，就发生了data race</li>
</ul>
<h3 id="Thread-Sanitizer的工作原理"><a href="#Thread-Sanitizer的工作原理" class="headerlink" title="Thread Sanitizer的工作原理"></a>Thread Sanitizer的工作原理</h3><blockquote>
<p>在WWDC的视频中也介绍过了，大家可以仔细看下视频，大致原理是记录每个线程访问变量的信息来做分析，值得一提的是，现阶段的Thread Sanitizer最多只同时记录4个线程的访问信息，在复杂的场景下，可能出现偶尔检测不出data race的场景，所以需要长时间经常性的运行来尽可能多的发现data race，这也是为什么苹果建议默认开启Thread Sanitizer，而且Thread Sanitizer造成的额外性能损耗非常之小。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程问题调试工具&lt;br&gt;
    
    </summary>
    
      <category term="Xcode" scheme="http://www.weixinbing.com/categories/Xcode/"/>
    
    
      <category term="Xcode" scheme="http://www.weixinbing.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>iOS并发编程(Concurrent Programming)上</title>
    <link href="http://www.weixinbing.com/2016/12/22/iOS%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(Concurrent%20Programming)%E4%B8%8A/"/>
    <id>http://www.weixinbing.com/2016/12/22/iOS并发编程(Concurrent Programming)上/</id>
    <published>2016-12-22T12:43:06.000Z</published>
    <updated>2016-12-24T12:10:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程和GCD<br><a id="more"></a></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>进程(process):</p>
<ul>
<li>正在运行中的程序(可执行文件)称为进程</li>
<li>拥有独立的虚拟内存空间和系统资源，包括端口权限等</li>
<li>当一个进程的主线程退出时，这个进程就结束了</li>
</ul>
<p>线程(thread): </p>
<ul>
<li>线程是进程中一个独立的代码执行路径(控制单元)</li>
<li>一个进程中至少包含一条线程，即主线程（又叫UI线程）</li>
<li>可以将耗时的执行路径(如：网络请求)放在其他线程中执行</li>
</ul>
<blockquote>
<p>在 iOS 中，线程的底层实现是基于 <code>POSIX threads API</code> 的，也就是我们常说的 pthreads</p>
</blockquote>
<p>任务(task):</p>
<ul>
<li>需要执行的工作，是一个抽象的概念</li>
<li>通俗的说，就是一段代码</li>
</ul>
<p>队列(queue):</p>
<ul>
<li>串行队列，队列中的任务只会顺序执行</li>
<li>并行队列，队列中的任务通常会并发执行</li>
</ul>
<blockquote>
<p>iOS 系统就是使用队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>
</blockquote>
<p>同步和异步:</p>
<ul>
<li>串行与并行针对的是队列，而同步与异步，针对的则是线程。</li>
<li>最大的区别在于，同步操作要阻塞当前线程，必须要等待同步操作中的任务执行完，返回以后，才能继续执行下一任务；而异步操作则是不用等待</li>
</ul>
<p>并发(concurrent)：</p>
<ul>
<li>同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。</li>
</ul>
<blockquote>
<p>调度原理</p>
<ul>
<li>多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将短暂的时间片(Timeslice)分配给每一个线程轮流使用CPU</li>
<li>由于CPU对每个时间片的处理速度非常快, 因此，用户看来好像这些任务在同时执行的</li>
<li>如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。</li>
</ul>
</blockquote>
<h2 id="多线程优势、弊端和误区"><a href="#多线程优势、弊端和误区" class="headerlink" title="多线程优势、弊端和误区"></a>多线程优势、弊端和误区</h2><p>优势:</p>
<ul>
<li>充分发挥多核处理器优势，将不同线程任务分配给不同的处理器，真正进入“并行运算”状态</li>
<li>将耗时的任务分配到其他线程执行，由主线程负责统一更新界面会使应用程序更加流畅，用户体验更好</li>
<li>当硬件处理器的数量增加，程序会运行更快，而程序无需做任何调整</li>
</ul>
<p>弊端:</p>
<ul>
<li>新建线程会消耗内存空间和CPU时间，线程太多会降低系统的运行性能</li>
</ul>
<p>误区:</p>
<ul>
<li>多线程技术是为了并发执行多项任务，不会提高单个算法本身的执行效率</li>
</ul>
<h2 id="iOS的三种多线程技术"><a href="#iOS的三种多线程技术" class="headerlink" title="iOS的三种多线程技术"></a>iOS的三种多线程技术</h2><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread 是 Objective-C 对 pthread 的一个封装。</p>
<ul>
<li>使用NSThread对象建立一个线程非常方便</li>
<li>但是！要使用NSThread管理多个线程非常困难，不推荐使用</li>
<li>技巧！使用[NSThread currentThread]跟踪任务所在线程(包括GCD和Operation Queues)</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。</p>
<ul>
<li>是基于C语言的底层API</li>
<li>用Block定义任务，使用起来非常灵活便捷</li>
<li>提供了更多的控制能力以及操作队列中所不能使用的底层函数</li>
</ul>
<h3 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h3><p>操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。</p>
<ul>
<li>是使用GCD实现的一套Objective-C的API</li>
<li>是面向对象的多线程技术</li>
<li>提供了一些在GCD中不容易实现的特性，如：限制最大并发数量、操作之间的依赖关系</li>
</ul>
<p>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="built_in">NSOperationQueue</span> mainQueue] <span class="comment">//获取主队列</span></div><div class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc] init]; <span class="comment">//自定义队列</span></div></pre></td></tr></table></figure></p>
<p>主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。</p>
<h2 id="Grand-Central-Dispatch（GCD）"><a href="#Grand-Central-Dispatch（GCD）" class="headerlink" title="Grand Central Dispatch（GCD）"></a>Grand Central Dispatch（GCD）</h2><p>GCD的基本思想是就将操作放在队列中去执行</p>
<blockquote>
<p>操作使用Blocks定义<br>队列负责调度操作执行所在的线程以及具体的执行时间<br>队列的特点是先进先出(FIFO)的，新添加至队列的操作都会排在队尾</p>
</blockquote>
<p>提示:</p>
<ul>
<li>GCD的函数都是以dispatch开头的</li>
</ul>
<p>操作:</p>
<ul>
<li>dispatch_async 异步操作</li>
<li>dispatch_sync 同步操作</li>
</ul>
<p>注：</p>
<ul>
<li>队列不是线程？也不表示对应的CPU</li>
<li>队列就是负责调度的! 谁空闲，就把任务给谁！</li>
<li>多线程技术的目的，就是为了在一个CPU上实现快速切换！</li>
</ul>
<h3 id="GCD队列-dispatch-queue-t"><a href="#GCD队列-dispatch-queue-t" class="headerlink" title="GCD队列(dispatch_queue_t)"></a>GCD队列(dispatch_queue_t)</h3><p>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</p>
<p><img src="http://oihqdel9t.bkt.clouddn.com/2016/12/Blog/gcd-queues.png" alt="GCD队列示意图"></p>
<blockquote>
<p>无论什么队列和什么任务，线程的创建和回收不需要程序员参与。<br>线程的创建回收工作是由队列负责的<br>“并发”编程，为了让程序员从负责的线程控制中解脱出来！只需要面对队列和任务！</p>
</blockquote>
<h4 id="GCD串行队列"><a href="#GCD串行队列" class="headerlink" title="GCD串行队列"></a>GCD串行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.s"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//异步操作会新建线程, 任务顺序执行(非常有用)</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GCD并行队列"><a href="#GCD并行队列" class="headerlink" title="GCD并行队列"></a>GCD并行队列</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.c"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//异步操作会新建多个线程, 任务无序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GCD全局队列"><a href="#GCD全局队列" class="headerlink" title="GCD全局队列"></a>GCD全局队列</h4><p>全局队列与并行队列的区别:</p>
<ul>
<li>不需要创建，直接GET就能用</li>
<li>两个队列的执行效果相同</li>
<li>全局队列没有名称，调试时，无法确认准确队列</li>
</ul>
<blockquote>
<p><code>强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。</code><br>如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，造成<code>优先级反转</code>，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q =dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">//同步操作不会新建线程, 任务顺序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//异步操作会新建多个线程, 任务无序执行</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="GCD主队列"><a href="#GCD主队列" class="headerlink" title="GCD主队列"></a>GCD主队列</h4><p>在iOS开发中，所有UI的更新工作，都必须在主线程上执行！<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</div><div class="line"><span class="comment">//同步操作会造成死锁,永远不会执行</span></div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"come here baby!"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 异步操作，在主线程上运行，同时是保持队形的</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@ - %d"</span>, [<span class="built_in">NSThread</span> currentThread], i);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="GCD不同队列种嵌套dispatch-sync的结果"><a href="#GCD不同队列种嵌套dispatch-sync的结果" class="headerlink" title="GCD不同队列种嵌套dispatch_sync的结果"></a>GCD不同队列种嵌套dispatch_sync的结果</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全局队列，都在主线程上执行，不会死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">// 并行队列，都在主线程上执行，不会死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.c"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">// 串行队列，会死锁，但是会执行嵌套同步操作之前的代码</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.s"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">// 直接死锁</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line"><span class="built_in">dispatch_sync</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"同步任务 %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>dispatch_sync的应用场景:</p>
<ul>
<li>阻塞并行队列的执行，要求某一操作执行后再进行后续操作，如用户登录</li>
<li>确保块代码之外的局部变量确实被修改</li>
</ul>
<h3 id="GCD死锁"><a href="#GCD死锁" class="headerlink" title="GCD死锁"></a>GCD死锁</h3><p>这里有篇博客已经介绍得非常详细了,图文并茂, 浅显易懂<br><a href="http://www.saitjr.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">某妹纸博客</a></p>
<h3 id="GCD队列组（Group-queue）"><a href="#GCD队列组（Group-queue）" class="headerlink" title="GCD队列组（Group queue）"></a>GCD队列组（Group queue）</h3><ul>
<li>Group queue 可以通过调用dispatch_group_create()来获取，通过dispatch_group_notify,可以直接监听组里所有线程完成情况。</li>
<li>当遇到需要执行多个线程并发执行，然后等多个线程都结束之后，再汇总执行结果时可以用group queue</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_t groupQueue = dispatch_group_create();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line">dispatch_group_async(groupQueue, q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"并行任务1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(groupQueue, q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"并行任务2"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(groupQueue, mainQueue, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"groupQueue中的任务 都执行完成,回到主线程更新UI"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div></pre></td></tr></table></figure>
<h3 id="GCD常用系统方法"><a href="#GCD常用系统方法" class="headerlink" title="GCD常用系统方法"></a>GCD常用系统方法</h3><h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><ul>
<li>保证在app运行期间，block中的代码只执行一次</li>
<li>经典使用场景－－－单例</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</div><div class="line"><span class="keyword">static</span> <span class="keyword">id</span> instance = <span class="literal">nil</span>;</div><div class="line"><span class="comment">// 使用GCD</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line"><span class="comment">// 保证代码执行一次</span></div><div class="line">instance = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc]init];</div><div class="line">&#125;);</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><ul>
<li>延时添加到队列</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t delayTime3 = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>*<span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_time_t delayTime2 = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line">dispatch_after(delayTime3, mainQueue, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"3秒之后添加到队列"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_after(delayTime2, mainQueue, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"2秒之后添加到队列"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div></pre></td></tr></table></figure>
<h4 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h4><ul>
<li>在给定的队列上多次执行某一任务</li>
<li>是同步执行的函数, 在主线程直接调用会阻塞主线程去执行block中的任务</li>
<li>一般把dispatch_apply放在异步队列中调用，然后执行完成后通知主线程</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line"><span class="built_in">dispatch_queue_t</span> applyQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// 3表示重复次数</span></div><div class="line">dispatch_apply(<span class="number">3</span>, applyQueue, ^(size_t index) &#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current index %@"</span>,@(index));</div><div class="line">sleep(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dispatch_apply 执行完成"</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line"><span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"回到主线程更新UI"</span>);</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div></pre></td></tr></table></figure>
<h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><ul>
<li>栅栏的作用</li>
<li>功能：在并行队列中，等待在dispatch_barrier_async之前加入队列的任务全部执行完成之后，再执行dispatch_barrier_async中的任务，再去执行在dispatch_barrier_async之后加入到队列中的任务。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> q = dispatch_queue_create(<span class="string">"com.name.c"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dispatch 1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_barrier_async(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dispatch barrier"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">dispatch_async</span>(q, ^&#123;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"dispatch 2"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程和GCD&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.weixinbing.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://www.weixinbing.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发编程" scheme="http://www.weixinbing.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Xcode8如何使用插件</title>
    <link href="http://www.weixinbing.com/2016/12/21/Xcode8.1%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.weixinbing.com/2016/12/21/Xcode8.1如何使用插件/</id>
    <published>2016-12-21T14:29:49.000Z</published>
    <updated>2017-01-19T14:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode8安装插件<br><a id="more"></a></p>
<p>1.安装苹果官方Xcode8<br>2.在Finder应用程序中将Xcode8复制一份(打包上架使用)<br>3.打开<code>钥匙串访问</code><img src="http://oihqdel9t.bkt.clouddn.com/2016/12/Blog/create%20certificate.png" alt="Alt text"><br>4.填写如图<img src="http://oihqdel9t.bkt.clouddn.com/2016/12/Blog/create%20certificate.png" alt="Alt text"></p>
<blockquote>
<p>第一行名称填写XcodeSigner<br>第二行不变<br>第三行选代码签名</p>
</blockquote>
<p>5.终端运行(要等10多分钟,固态硬盘会快一些)<br><code>sudo codesign -f -s XcodeSigner /Applications/Xcode.app</code></p>
<p>6.这时你可以安装Alcatraz了<a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="external">github地址</a></p>
<blockquote>
<p>本人使用如下的终端命令来安装Alcatraz:<br><code>curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</code><br>如果你不想使用Alcatraz了,可以使用如下命令来删除:<br><code>rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin</code><br>删除所有通过Alcatraz安装的安装包<br><code>rm -rf ~/Library/Application\ Support/Alcatraz/</code></p>
</blockquote>
<p>7.Xcode 插件升级失效解决办法</p>
<blockquote>
<p>使用以下终端命令<br>获取DVTPlugInCompatibilityUUID字段<br><code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code><br>将XXXX替换成刚刚获取的DVTPlugInCompatibilityUUID<br><code>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add XXXX</code></p>
</blockquote>
<p>8.打开一个Xcode project, 选择load bundle,再次打开工程,已经可以愉快的使用插件了.</p>
<p>参考文章:<a href="http://www.cocoachina.com/bbs/read.php?tid=1705417" target="_blank" rel="external">http://www.cocoachina.com/bbs/read.php?tid=1705417</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode8安装插件&lt;br&gt;
    
    </summary>
    
      <category term="Xcode" scheme="http://www.weixinbing.com/categories/Xcode/"/>
    
    
      <category term="插件" scheme="http://www.weixinbing.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="plugs" scheme="http://www.weixinbing.com/tags/plugs/"/>
    
  </entry>
  
  <entry>
    <title>发布框架到cocoapods</title>
    <link href="http://www.weixinbing.com/2016/12/20/%E5%8F%91%E5%B8%83%E5%B7%A5%E7%A8%8B%E5%88%B0cocoapods/"/>
    <id>http://www.weixinbing.com/2016/12/20/发布工程到cocoapods/</id>
    <published>2016-12-20T02:02:34.000Z</published>
    <updated>2016-12-24T11:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>让自己的框架支持cocoapods<br><a id="more"></a></p>
<h3 id="在github建立仓库-并clone到本地"><a href="#在github建立仓库-并clone到本地" class="headerlink" title="在github建立仓库,并clone到本地"></a>在github建立仓库,并clone到本地</h3><p>github不是唯一的平台,其他平台都可以,前提是项目是开源的.</p>
<h3 id="创建-podspec文件"><a href="#创建-podspec文件" class="headerlink" title="创建.podspec文件"></a>创建.podspec文件</h3><p>打开终端,进入仓库,执行如下命令:</p>
<blockquote>
<p>pod spec create XXX</p>
</blockquote>
<h3 id="编辑-podspec文件"><a href="#编辑-podspec文件" class="headerlink" title="编辑.podspec文件"></a>编辑.podspec文件</h3><p>使用vim或Xcode打开.podspec文件,编辑如下:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|</div><div class="line">s.name = <span class="string">"XXX"</span></div><div class="line">s.<span class="keyword">version</span> = <span class="string">"1.0.3"</span></div><div class="line">s.ios.deployment_target = <span class="string">'8.0'</span></div><div class="line">s.summary = <span class="string">"some utilities"</span></div><div class="line">s.homepage = <span class="string">"https://github.com/weixinbing/XXX"</span></div><div class="line">s.license = &#123; :<span class="built_in">type</span> =&gt; <span class="string">"MIT"</span>, :<span class="keyword">file</span> =&gt; <span class="string">"LICENSE"</span> &#125;</div><div class="line">s.author = &#123; <span class="string">"weixb"</span> =&gt; <span class="string">"183292352@qq.com"</span> &#125;</div><div class="line">s.social_media_url = <span class="string">"http://weibo.com/u/5348162268"</span></div><div class="line">s.<span class="keyword">source</span> = &#123; :git =&gt; <span class="string">"https://github.com/weixinbing/XXX.git"</span>, :<span class="keyword">tag</span> =&gt; s.<span class="keyword">version</span> &#125;</div><div class="line">s.source_files = <span class="string">"XXX"</span></div><div class="line">s.requires_arc = true</div><div class="line">s.dependency <span class="string">"YTKNetwork"</span>, <span class="string">"~&gt; 2.0.3"</span></div><div class="line">s.dependency <span class="string">'Bugly'</span>, <span class="string">'~&gt; 2.4.2'</span></div><div class="line">end</div></pre></td></tr></table></figure></p>
<blockquote>
<p>s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错<br>s.version：版本号<br>s.ios.deployment_target:支持的pod最低版本<br>s.summary: 简介<br>s.homepage:项目主页地址<br>s.license:许可证<br>s.author:作者<br>s.social_media_url:社交网址<br>s.source:项目的地址<br>s.source_files:需要包含的源文件<br>s.resources: 资源文件<br>s.requires_arc: 是否支持ARC<br>s.dependency：依赖库(可以多写)</p>
</blockquote>
<p>source_files:写法及含义:</p>
<blockquote>
<p>“”XXX”和“XXX/<em>” 表示匹配所有文件(不包含文件夹)<br>“XXX/</em>.{h,m}” 表示匹配所有以.h和.m结尾的文件(不包含文件夹)<br>“XXX/**” 表示匹配所有子目录(不包含文件夹)</p>
</blockquote>
<h3 id="验证本地仓库-podspec文件"><a href="#验证本地仓库-podspec文件" class="headerlink" title="验证本地仓库.podspec文件"></a>验证本地仓库.podspec文件</h3><blockquote>
<p>pod lib lint XXX.podspec</p>
</blockquote>
<h3 id="上传本地仓库到Git"><a href="#上传本地仓库到Git" class="headerlink" title="上传本地仓库到Git"></a>上传本地仓库到Git</h3><h3 id="给仓库打上tag"><a href="#给仓库打上tag" class="headerlink" title="给仓库打上tag"></a>给仓库打上tag</h3><blockquote>
<p>git tag ‘1.0.0’ //第一步<br>git push origin –tags //推送到远程仓库</p>
</blockquote>
<h3 id="验证远程仓库-podspec文件"><a href="#验证远程仓库-podspec文件" class="headerlink" title="验证远程仓库.podspec文件"></a>验证远程仓库.podspec文件</h3><blockquote>
<p>pod spec lint XXX.podspec</p>
</blockquote>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>发布前先验证是否已注册trunk：</p>
<blockquote>
<p>pod trunk me</p>
</blockquote>
<p>没有注册则使用命令：</p>
<blockquote>
<p>pod trunk register Email “Name” –verbose<br>注册完成之后会给你的邮箱发个邮件,进入邮箱邮件里面有个链接,需要点击确认一下</p>
</blockquote>
<p>已注册则执行发布命令：</p>
<blockquote>
<p>pod trunk push XXX.podspec</p>
</blockquote>
<p>发布成功就可以使用pod导入你的框架了。</p>
<h3 id="错误搜集"><a href="#错误搜集" class="headerlink" title="错误搜集"></a>错误搜集</h3><p>遇到错误CocoaPods was not able to update the <code>master</code> repo. If this is an unexpected issue and persists you can inspect it running <code>pod repo update --verbose</code><br>执行命令<code>pod repo update</code>即可</p>
<p>发布成功,执行<code>pod search XXX</code>搜索</p>
<p>遇到错误Unable to find a pod with name, author, summary, or descriptionmatching “XXX”的解决方法:</p>
<blockquote>
<p>方法1:使用终端命令<br><code>rm ~/Library/Caches/CocoaPods/search_index.json</code>  删除cocoapods本地缓存,再使用<code>pod search XXX</code>搜索.<br>方法2:使用终端命令<code>pod setup</code> 更新cocoapods的repo,再重复方法1.</p>
</blockquote>
<p>依赖错误, 可以使用 –use-libraries 来让验证通过.<br>警告错误, 可以使用 –allow-warnings 来让验证通过.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;让自己的框架支持cocoapods&lt;br&gt;
    
    </summary>
    
      <category term="cocoapods" scheme="http://www.weixinbing.com/categories/cocoapods/"/>
    
    
      <category term="cocoapods" scheme="http://www.weixinbing.com/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>YYModel,MJExtension,JSONModel对比</title>
    <link href="http://www.weixinbing.com/2016/12/20/YYModel,MJExtension,JSONModel%E5%AF%B9%E6%AF%94/"/>
    <id>http://www.weixinbing.com/2016/12/20/YYModel,MJExtension,JSONModel对比/</id>
    <published>2016-12-19T16:02:25.000Z</published>
    <updated>2017-07-16T14:42:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>JSON模型<br><a id="more"></a></p>
<h3 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h3><blockquote>
<p>JSONModel要求所有模型类必须继承自JSONModel基类<br>YYModel和MJExtension不需要你的模型类继承任何特殊基类，毫无污染，毫无侵入性</p>
</blockquote>
<h3 id="量级上"><a href="#量级上" class="headerlink" title="量级上"></a>量级上</h3><blockquote>
<p>YYModel和MJExtension都是超轻量级框架<br>YYModel是一个更轻量级高性能 iOS/OSX 模型转换框架,模型转换性能接近手写解析代码,比MJExtension和JSONModel性能更高.</p>
</blockquote>
<h3 id="字典和模型之间互相转换"><a href="#字典和模型之间互相转换" class="headerlink" title="字典和模型之间互相转换"></a>字典和模型之间互相转换</h3><blockquote>
<p>MJExtension支持:<br>Plist –&gt; Model Array<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">模型数组 = [模型类名 objectArrayWithFilename:<span class="string">@"文件名.plist"</span>];</div></pre></td></tr></table></figure></p>
<p>JSON Array –&gt; Model Array<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *modelArray = [模型类名 objectArrayWithKeyValuesArray:字段数组];</div></pre></td></tr></table></figure></p>
<p>JSONString –&gt; Model Array<br>Model Array –&gt; JSON Array<br>YYModel没有看到对字典数组和模型数组相互转换的支持</p>
</blockquote>
<h3 id="容器类属性"><a href="#容器类属性" class="headerlink" title="容器类属性"></a>容器类属性</h3><blockquote>
<p>YYModel需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)modelContainerPropertyGenericClass &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"arrayName"</span> : [模型类名 <span class="keyword">class</span>]&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MJExtension需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)objectClassInArray &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"arrayName"</span> : [模型类名 <span class="keyword">class</span>]&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p> <code>MJExtension可以配合ESJsonFormat模型插件使用,插件自动实现容器方法.YYModel也可以配合ESJsonFormat模型插件使用,需要修改容器实现的方法名.</code></p>
<blockquote>
<p>JSONModel是最简单的,只需要参照以下写法即可<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> &lt;ProductModel&gt; *products;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="归档和解档"><a href="#归档和解档" class="headerlink" title="归档和解档"></a>归档和解档</h3><blockquote>
<p>三者性能相当<br>MJExtension只需要一行代码调用写好的宏MJExtensionCodingImplementation就可以实现<br>YYModel需要遵守NSCoding协议,并重写下面方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder &#123; [<span class="keyword">self</span> yy_modelEncodeWithCoder:aCoder]; &#125;</div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123; <span class="keyword">self</span> = [<span class="keyword">super</span> init]; <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelInitWithCoder:aDecoder]; &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><blockquote>
<p>MJExtension只需要在@implementation 和 @end之间写上宏MJLogAllIvrs,就能解决调试时，打印模型，只打印出内存地址的问题<br>YYModel需要重写description方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)description &#123; <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelDescription]; &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="模型中的属性名和字典中的key不相同-或者需要多级映射"><a href="#模型中的属性名和字典中的key不相同-或者需要多级映射" class="headerlink" title="模型中的属性名和字典中的key不相同(或者需要多级映射)"></a>模型中的属性名和字典中的key不相同(或者需要多级映射)</h3><blockquote>
<p>YYModel需要在 @implementation 和 @end之间 写上<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSDictionary</span> *)modelCustomPropertyMapper &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"name"</span> : <span class="string">@"n"</span>,</div><div class="line">             <span class="string">@"page"</span> : <span class="string">@"p"</span>,</div><div class="line">             <span class="string">@"desc"</span> : <span class="string">@"ext.desc"</span>,</div><div class="line">             <span class="string">@"bookID"</span> : @[<span class="string">@"id"</span>,<span class="string">@"ID"</span>,<span class="string">@"book_id"</span>]</div><div class="line">             &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>MJExtension需要在转换代码之前实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[Student mj_setupReplacedKeyFromPropertyName:^<span class="built_in">NSDictionary</span> *&#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">               <span class="string">@"ID"</span> : <span class="string">@"id"</span>,</div><div class="line">               <span class="string">@"desc"</span> : <span class="string">@"desciption"</span>,</div><div class="line">               <span class="string">@"oldName"</span> : <span class="string">@"name.oldName"</span>,</div><div class="line">               <span class="string">@"nowName"</span> : <span class="string">@"name.newName"</span>,</div><div class="line">               <span class="string">@"nameChangedTime"</span> : <span class="string">@"name.info[1].nameChangedTime"</span>,</div><div class="line">               <span class="string">@"bag"</span> : <span class="string">@"other.bag"</span></div><div class="line">           &#125;;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON模型&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.weixinbing.com/categories/iOS/"/>
    
    
      <category term="JSON" scheme="http://www.weixinbing.com/tags/JSON/"/>
    
      <category term="MODEL" scheme="http://www.weixinbing.com/tags/MODEL/"/>
    
      <category term="模型框架" scheme="http://www.weixinbing.com/tags/%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>OC预处理指令</title>
    <link href="http://www.weixinbing.com/2016/12/19/OC%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.weixinbing.com/2016/12/19/OC预处理命令/</id>
    <published>2016-12-18T16:42:26.000Z</published>
    <updated>2016-12-24T11:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>深入了解预处理指令</p>
<a id="more"></a>
<p>预处理指令是以#号开头的代码行。#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。<br>指令用途：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#空指令，无任何效果</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span>包含一个源代码文件</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>定义宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span>取消已定义的宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> 如果给定条件为真，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>如果宏已经定义，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>如果宏没有定义，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span>如果前面的#<span class="meta-keyword">if</span>给定条件不为真，当前条件为真，则编译下面代码</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>结束一个#<span class="meta-keyword">if</span>……#<span class="meta-keyword">else</span>条件编译块</span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span>停止编译并显示错误信息</span></div></pre></td></tr></table></figure></p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><code>#include</code>预处理指令的作用是在指令处展开被包含的文件。包含可以是多重的，也就是说一个被包含的文件中还可以包含其他文件。标准C编译器至少支持八重嵌套包含。</p>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>宏定义了一个代表特定内容的标识符。预处理过程会把源代码中出现的宏标识符替换成宏定义时的值。宏最常见的用法是定义代表某个值的全局符号。宏的第二种用法是定义带参数的宏，这样的宏可以象函数一样被调用，但它是在调用语句处展开宏，并用调用时的实际参数来代替定义中的形式参数。</p>
<p><code>#运算符</code><br>出现在宏定义中的#运算符把跟在其后的参数转换成一个字符串。有时把这种用法的#称为字符串化运算符。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#definePASTE(n)<span class="meta-string">"adhfkj"</span>#n</span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%s "</span>,PASTE(<span class="number">15</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>宏定义中的#运算符告诉预处理程序，把源代码中任何传递给该宏的参数转换成一个字符串。所以输出应该是adhfkj15。</p>
<p><code>##运算符</code><br>用于把参数连接到一起。预处理程序把出现在##两侧的参数合并成一个符号。看下面的例子：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#defineNUM(a,b,c)a##b##c</span></div><div class="line"><span class="meta">#defineSTR(a,b,c)a##b##c</span></div><div class="line">main()</div><div class="line">&#123;</div><div class="line">printf(<span class="string">"%d "</span>,NUM(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</div><div class="line">printf(<span class="string">"%s "</span>,STR(<span class="string">"aa"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>));</div><div class="line">&#125;</div><div class="line">最后程序的输出为:</div><div class="line"><span class="number">123</span></div><div class="line">aabbcc1</div></pre></td></tr></table></figure></p>
<h2 id="条件编译指令"><a href="#条件编译指令" class="headerlink" title="条件编译指令"></a>条件编译指令</h2><p>条件编译指令将决定那些代码被编译，而哪些是不被编译的。可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件。</p>
<h3 id="if指令"><a href="#if指令" class="headerlink" title="#if指令"></a><code>#if指令</code></h3><p>检测跟在制造另关键字后的常量表达式。如果表达式为真，则编译后面的代码，知道出现#else、#elif或#endif为止；否则就不编译。</p>
<h3 id="endif指令"><a href="#endif指令" class="headerlink" title="#endif指令"></a><code>#endif指令</code></h3><p>用于终止#if预处理指令。</p>
<h3 id="ifdef和-ifndef"><a href="#ifdef和-ifndef" class="headerlink" title="#ifdef和#ifndef"></a><code>#ifdef和#ifndef</code></h3><p>用于#define命令定义过则进行编译</p>
<h3 id="else指令"><a href="#else指令" class="headerlink" title="#else指令"></a><code>#else指令</code></h3><p>用于某个#if指令之后，当前面的#if指令的条件不为真时，就编译#else后面的代码。#endif指令将中指上面的条件块。</p>
<h3 id="elif指令"><a href="#elif指令" class="headerlink" title="#elif指令"></a><code>#elif指令</code></h3><p>综合了#else和#if指令的作用。</p>
<h3 id="其他一些标准指令"><a href="#其他一些标准指令" class="headerlink" title="其他一些标准指令"></a><code>其他一些标准指令</code></h3><blockquote>
<p><code>#error</code>指令将使编译器显示一条错误信息，然后停止编译。<br><code>#line</code>指令可以改变编译器用来指出警告和错误信息的文件号和行号。<br><code>#pragma</code>指令没有正式的定义。编译器可以自定义其用途。典型的用法是禁止或允许某些烦人的警告信息。</p>
</blockquote>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>预处理就是在进行编译的第一遍词法扫描和语法分析之前所作的工作。说白了，就是对源文件进行编译前，先对预处理部分进行处理，然后对处理后的代码进行编译。这样做的好处是，经过处理后的代码，将会变的很精短。</p>
<h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdef _XXXX</span></div><div class="line">...程序段<span class="number">1.</span>..</div><div class="line"><span class="meta">#else</span></div><div class="line">...程序段<span class="number">2.</span>..</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这表明如果标识符_XXXX已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。</p>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef _XXXX </span></div><div class="line">...程序段<span class="number">1.</span>.. </div><div class="line"><span class="meta">#else </span></div><div class="line">...程序段<span class="number">2.</span>.. </div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这里使用了#ifndef，表示的是if not def。当然是和#ifdef相反的状况（如果没有定义了标识符_XXXX，那么执行程序段1，否则执行程序段2）。例子就不举了。</p>
<h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if 常量 </span></div><div class="line">...程序段<span class="number">1.</span>..</div><div class="line"><span class="meta">#else</span></div><div class="line">...程序段<span class="number">2.</span>..</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>这里表示，如果常量为真（非0，随便什么数字，只要不是0），就执行程序段1，否则执行程序段2。<br>我认为，这种方法可以将测试代码加进来。当需要开启测试的时候，只要将常量变1就好了。而不要测试的时候，只要将常量变0。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入了解预处理指令&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.weixinbing.com/categories/Objective-C/"/>
    
    
      <category term="预处理" scheme="http://www.weixinbing.com/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>快速搭建个人博客</title>
    <link href="http://www.weixinbing.com/2016/12/18/Hexo%20%E7%BB%93%E5%90%88%20Github%20%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.weixinbing.com/2016/12/18/Hexo 结合 Github 搭建的博客/</id>
    <published>2016-12-18T11:00:27.000Z</published>
    <updated>2018-12-03T04:14:10.261Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 结合 Github 搭建博客<br><a id="more"></a></p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul>
<li>安装Node.js <a href="https://nodejs.org/en/" target="_blank" rel="external">官网https://nodejs.org/en/</a></li>
<li>安装Git（Xcode自带有Git）</li>
<li>注册GitHub账号（用于博客的远程仓库）</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>打开终端，执行命令：</p>
<pre><code>npm install hexo-cli -g
</code></pre><p>如果报错，加上sudo。<br>hexo常用命令：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo g   <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></div><div class="line">hexo s   <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></div><div class="line">hexo d   <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github上</span></div><div class="line">hexo n   <span class="comment">#完整命令为hexo new,用于新建一篇文章</span></div><div class="line">hexo clean   <span class="comment">#清除生成的文件</span></div></pre></td></tr></table></figure></p>
<h2 id="初始化博客文件夹"><a href="#初始化博客文件夹" class="headerlink" title="初始化博客文件夹"></a>初始化博客文件夹</h2><pre><code>hexo init [文件夹名字] 
cd [文件夹名字] 
npm install
</code></pre><p>成功后执行下面命令，运行服务，就可以在浏览器中访问了，地址为： <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> ：</p>
<pre><code>hexo s
</code></pre><p>如果遇到 hexo s 无效或者错误，可能是因为没有安装hexo server，执行下面命令，然后再试：</p>
<pre><code>npm install hexo-server --save
</code></pre><h2 id="编辑hexo的配置文件"><a href="#编辑hexo的配置文件" class="headerlink" title="编辑hexo的配置文件"></a>编辑hexo的配置文件</h2><p>不要被文件内容吓到了，只需要修改以下地方：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line"><span class="symbol">title:</span> xxx</div><div class="line"><span class="symbol">subtitle:</span> xxx</div><div class="line"><span class="symbol">description:</span> xxx</div><div class="line"><span class="symbol">author:</span> xxx</div><div class="line"><span class="symbol">language:</span> zh-Hans</div><div class="line"><span class="symbol">timezone:</span> Asia/Shanghai</div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Deployment</span></div><div class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></div><div class="line"><span class="symbol">deploy:</span></div><div class="line">  <span class="symbol">type:</span> git</div><div class="line">  <span class="symbol">repo:</span> github仓库的克隆地址</div><div class="line">  <span class="symbol">branch:</span> master</div></pre></td></tr></table></figure>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通常情况下是先生成网站，然后部署。可以将两个步骤放到一起：</p>
<pre><code>hexo d -g
</code></pre><p>现在你就可以打开网站看到效果了。<br>如果提示：</p>
<pre><code>ERROR Deployer not found:git
</code></pre><p>需要要安装hexo-deployer-git：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>完成后执行部署命令hexo d -g。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>通过以下命令新建文章：</p>
<pre><code>hexo new “文章名字&quot;
</code></pre><p>然后用编辑器打开 source_posts 里的md文件编辑。<br>更新文章：</p>
<pre><code>hexo d -g
</code></pre><p>这样就可以把你的新文章传上去啦。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://github.com/iissnan/hexo-theme-next/wiki" target="_blank" rel="external">NexT 官方WiKi</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT 官方网站</a></p>
<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>现在默认的域名还是xxx.github.io，是不是很没有牌面？想不想也像我一样弄一个专属域名呢，首先你得购买一个域名，xx云都能买，看你个人喜好了。</p>
<p>以我的阿里云为例，如下图所示，添加两条解析记录：</p>
<table>
<thead>
<tr>
<th>记录类型</th>
<th>主机记录</th>
<th>解析线路(isp)</th>
<th>记录值</th>
<th>MX优先级</th>
<th>TTL</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNAME</td>
<td>@</td>
<td>默认</td>
<td>weixinbing.github.io</td>
<td>–</td>
<td>10分钟</td>
<td>正常</td>
</tr>
<tr>
<td>CNAME</td>
<td>www</td>
<td>默认</td>
<td>weixinbing.github.io</td>
<td>–</td>
<td>10分钟</td>
<td>正常</td>
</tr>
</tbody>
</table>
<p>然后打开你的github博客项目，点击settings，拉到下面Custom domain处，填上你自己的域名，保存</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 结合 Github 搭建博客&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://www.weixinbing.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
